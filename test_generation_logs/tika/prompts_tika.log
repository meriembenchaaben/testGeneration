
====================================================================================================
PROMPTS LOG SESSION STARTED: 2026-01-27T04:14:56.406915
====================================================================================================

====================================================================================================
TEST CASE 1/24 — ITERATION 1
Entry Point: org.apache.tika.config.TikaActivator.start(org.osgi.framework.BundleContext)
Third Party Method: org.osgi.util.tracker.ServiceTracker.open()
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.config.TikaActivator.start(org.osgi.framework.BundleContext)
thirdPartyMethod: org.osgi.util.tracker.ServiceTracker.open()
path: org.apache.tika.config.TikaActivator.start(org.osgi.framework.BundleContext) -> org.osgi.util.tracker.ServiceTracker.open()
methodSources:
```java
// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception // PATH: Test should invoke the next ServiceTracker.open(...) [step in execution path]
{
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}
```
constructors:
```java
TikaActivator() {
}
```
fieldDeclarations:
```java
private ServiceTracker detectorTracker;
private ServiceTracker parserTracker;
private BundleContext bundleContext;
```
setters:
```java
public void removedService(ServiceReference reference, Object service) {
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}

// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception {
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}

public void stop(BundleContext context) throws Exception {
    parserTracker.close();
    detectorTracker.close();
}
```
imports: org.apache.tika.detect.Detector, org.apache.tika.parser.Parser, org.osgi.framework.BundleContext, org.osgi.framework.Constants, org.osgi.framework.ServiceReference, org.osgi.util.tracker.ServiceTracker

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.config
- class name MUST be: TikaActivatorstart_ServiceTrackeropenFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):



====================================================================================================
TEST CASE 1/24 — ITERATION 2
Entry Point: org.apache.tika.config.TikaActivator.start(org.osgi.framework.BundleContext)
Third Party Method: org.osgi.util.tracker.ServiceTracker.open()
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.config.TikaActivator.start(org.osgi.framework.BundleContext)
thirdPartyMethod: org.osgi.util.tracker.ServiceTracker.open()
path: org.apache.tika.config.TikaActivator.start(org.osgi.framework.BundleContext) -> org.osgi.util.tracker.ServiceTracker.open()
methodSources:
```java
// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception // PATH: Test should invoke the next ServiceTracker.open(...) [step in execution path]
{
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}
```
constructors:
```java
TikaActivator() {
}
```
fieldDeclarations:
```java
private ServiceTracker detectorTracker;
private ServiceTracker parserTracker;
private BundleContext bundleContext;
```
setters:
```java
public void removedService(ServiceReference reference, Object service) {
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}

// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception {
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}

public void stop(BundleContext context) throws Exception {
    parserTracker.close();
    detectorTracker.close();
}
```
imports: org.apache.tika.detect.Detector, org.apache.tika.parser.Parser, org.osgi.framework.BundleContext, org.osgi.framework.Constants, org.osgi.framework.ServiceReference, org.osgi.util.tracker.ServiceTracker

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.config
- class name MUST be: TikaActivatorstart_ServiceTrackeropenFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatorstart_ServiceTrackeropenFikaTest.java:[10,26] package org.mockito does not exist
[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatorstart_ServiceTrackeropenFikaTest.java:[10,1] static import only from classes and interfaces
[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatorstart_ServiceTrackeropenFikaTest.java:[11,26] package org.mockito does not exist
[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatorstart_ServiceTrackeropenFikaTest.java:[11,1] static import only from classes and interfaces

================================================================================



====================================================================================================
TEST CASE 1/24 — ITERATION 3
Entry Point: org.apache.tika.config.TikaActivator.start(org.osgi.framework.BundleContext)
Third Party Method: org.osgi.util.tracker.ServiceTracker.open()
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.config.TikaActivator.start(org.osgi.framework.BundleContext)
thirdPartyMethod: org.osgi.util.tracker.ServiceTracker.open()
path: org.apache.tika.config.TikaActivator.start(org.osgi.framework.BundleContext) -> org.osgi.util.tracker.ServiceTracker.open()
methodSources:
```java
// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception // PATH: Test should invoke the next ServiceTracker.open(...) [step in execution path]
{
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}
```
constructors:
```java
TikaActivator() {
}
```
fieldDeclarations:
```java
private ServiceTracker detectorTracker;
private ServiceTracker parserTracker;
private BundleContext bundleContext;
```
setters:
```java
public void removedService(ServiceReference reference, Object service) {
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}

// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception {
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}

public void stop(BundleContext context) throws Exception {
    parserTracker.close();
    detectorTracker.close();
}
```
imports: org.apache.tika.detect.Detector, org.apache.tika.parser.Parser, org.osgi.framework.BundleContext, org.osgi.framework.Constants, org.osgi.framework.ServiceReference, org.osgi.util.tracker.ServiceTracker

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.config
- class name MUST be: TikaActivatorstart_ServiceTrackeropenFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):

================================================================================
HARD CONSTRAINT VALIDATION FAILED
================================================================================

HARD CONSTRAINT VIOLATION: Test uses anonymous inner class(es).
  Found 1 anonymous inner class(es).
  Requirement: Do not create anonymous classes that override behavior.
  Fix: Use real object instances or mock objects without overriding methods.
  Anonymous inner classes implicitly extend/override the class behavior.

  Example 1 (class: BundleContext):
    ...BundleContext bundleContext = new BundleContext() {             public String getProperty(String key) { return null; }  ...

================================================================================
Please regenerate the test without these violations.
Remember:
  - The test class must be standalone (no 'extends' clause)
  - Do not override any methods (no @Override)
  - Do not create anonymous inner classes (new ClassName() {...})
  - Do not use Mockito stubbing (when/doReturn/thenReturn/etc.)
  - Do not use Mockito spy() or @Spy
  - Do not use Mockito verify() or verifications
  - All methods must execute their real, unaltered implementations
================================================================================



====================================================================================================
TEST CASE 1/24 — ITERATION 4
Entry Point: org.apache.tika.config.TikaActivator.start(org.osgi.framework.BundleContext)
Third Party Method: org.osgi.util.tracker.ServiceTracker.open()
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.config.TikaActivator.start(org.osgi.framework.BundleContext)
thirdPartyMethod: org.osgi.util.tracker.ServiceTracker.open()
path: org.apache.tika.config.TikaActivator.start(org.osgi.framework.BundleContext) -> org.osgi.util.tracker.ServiceTracker.open()
methodSources:
```java
// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception // PATH: Test should invoke the next ServiceTracker.open(...) [step in execution path]
{
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}
```
constructors:
```java
TikaActivator() {
}
```
fieldDeclarations:
```java
private ServiceTracker detectorTracker;
private ServiceTracker parserTracker;
private BundleContext bundleContext;
```
setters:
```java
public void removedService(ServiceReference reference, Object service) {
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}

// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception {
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}

public void stop(BundleContext context) throws Exception {
    parserTracker.close();
    detectorTracker.close();
}
```
imports: org.apache.tika.detect.Detector, org.apache.tika.parser.Parser, org.osgi.framework.BundleContext, org.osgi.framework.Constants, org.osgi.framework.ServiceReference, org.osgi.util.tracker.ServiceTracker

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.config
- class name MUST be: TikaActivatorstart_ServiceTrackeropenFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatorstart_ServiceTrackeropenFikaTest.java:[6,19] package org.mockito does not exist

================================================================================



====================================================================================================
TEST CASE 1/24 — ITERATION 5
Entry Point: org.apache.tika.config.TikaActivator.start(org.osgi.framework.BundleContext)
Third Party Method: org.osgi.util.tracker.ServiceTracker.open()
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.config.TikaActivator.start(org.osgi.framework.BundleContext)
thirdPartyMethod: org.osgi.util.tracker.ServiceTracker.open()
path: org.apache.tika.config.TikaActivator.start(org.osgi.framework.BundleContext) -> org.osgi.util.tracker.ServiceTracker.open()
methodSources:
```java
// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception // PATH: Test should invoke the next ServiceTracker.open(...) [step in execution path]
{
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}
```
constructors:
```java
TikaActivator() {
}
```
fieldDeclarations:
```java
private ServiceTracker detectorTracker;
private ServiceTracker parserTracker;
private BundleContext bundleContext;
```
setters:
```java
public void removedService(ServiceReference reference, Object service) {
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}

// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception {
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}

public void stop(BundleContext context) throws Exception {
    parserTracker.close();
    detectorTracker.close();
}
```
imports: org.apache.tika.detect.Detector, org.apache.tika.parser.Parser, org.osgi.framework.BundleContext, org.osgi.framework.Constants, org.osgi.framework.ServiceReference, org.osgi.util.tracker.ServiceTracker

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.config
- class name MUST be: TikaActivatorstart_ServiceTrackeropenFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatorstart_ServiceTrackeropenFikaTest.java:[4,19] package org.mockito does not exist

================================================================================



====================================================================================================
TEST CASE 2/24 — ITERATION 1
Entry Point: org.apache.tika.io.BoundedInputStream.transferTo(java.io.OutputStream)
Third Party Method: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.io.BoundedInputStream.transferTo(java.io.OutputStream)
thirdPartyMethod: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
path: org.apache.tika.io.BoundedInputStream.transferTo(java.io.OutputStream) -> org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
methodSources:
```java
@Override
public long transferTo(OutputStream out) throws IOException {
    // PATH: Test should invoke the next IOUtils.copy(...) [step in execution path]
    return IOUtils.copy(this, out);
}
```
constructors:
```java
public BoundedInputStream(long max, InputStream in) {
    this.max = max;
    this.in = in;
}
```
fieldDeclarations:
```java
private static final int EOF = -1;
private final long max;
private final InputStream in;
private long pos;
```
setters:
```java
@Override
public void mark(int readLimit) {
    in.mark(readLimit);
}

@Override
public void reset() throws IOException {
    in.reset();
    pos = 0;
}
```
imports: org.apache.commons.io.IOUtils

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.io
- class name MUST be: BoundedInputStreamtransferTo_IOUtilscopyFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):



====================================================================================================
TEST CASE 2/24 — ITERATION 2
Entry Point: org.apache.tika.io.BoundedInputStream.transferTo(java.io.OutputStream)
Third Party Method: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.io.BoundedInputStream.transferTo(java.io.OutputStream)
thirdPartyMethod: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
path: org.apache.tika.io.BoundedInputStream.transferTo(java.io.OutputStream) -> org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
methodSources:
```java
@Override
public long transferTo(OutputStream out) throws IOException {
    // PATH: Test should invoke the next IOUtils.copy(...) [step in execution path]
    return IOUtils.copy(this, out);
}
```
constructors:
```java
public BoundedInputStream(long max, InputStream in) {
    this.max = max;
    this.in = in;
}
```
fieldDeclarations:
```java
private static final int EOF = -1;
private final long max;
private final InputStream in;
private long pos;
```
setters:
```java
@Override
public void mark(int readLimit) {
    in.mark(readLimit);
}

@Override
public void reset() throws IOException {
    in.reset();
    pos = 0;
}
```
imports: org.apache.commons.io.IOUtils

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.io
- class name MUST be: BoundedInputStreamtransferTo_IOUtilscopyFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/io/BoundedInputStreamtransferTo_IOUtilscopyFikaTest.java:[4,19] package org.mockito does not exist

================================================================================



====================================================================================================
TEST CASE 2/24 — ITERATION 3
Entry Point: org.apache.tika.io.BoundedInputStream.transferTo(java.io.OutputStream)
Third Party Method: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.io.BoundedInputStream.transferTo(java.io.OutputStream)
thirdPartyMethod: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
path: org.apache.tika.io.BoundedInputStream.transferTo(java.io.OutputStream) -> org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
methodSources:
```java
@Override
public long transferTo(OutputStream out) throws IOException {
    // PATH: Test should invoke the next IOUtils.copy(...) [step in execution path]
    return IOUtils.copy(this, out);
}
```
constructors:
```java
public BoundedInputStream(long max, InputStream in) {
    this.max = max;
    this.in = in;
}
```
fieldDeclarations:
```java
private static final int EOF = -1;
private final long max;
private final InputStream in;
private long pos;
```
setters:
```java
@Override
public void mark(int readLimit) {
    in.mark(readLimit);
}

@Override
public void reset() throws IOException {
    in.reset();
    pos = 0;
}
```
imports: org.apache.commons.io.IOUtils

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.io
- class name MUST be: BoundedInputStreamtransferTo_IOUtilscopyFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/io/BoundedInputStreamtransferTo_IOUtilscopyFikaTest.java:[4,19] package org.mockito does not exist

================================================================================



====================================================================================================
TEST CASE 2/24 — ITERATION 4
Entry Point: org.apache.tika.io.BoundedInputStream.transferTo(java.io.OutputStream)
Third Party Method: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.io.BoundedInputStream.transferTo(java.io.OutputStream)
thirdPartyMethod: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
path: org.apache.tika.io.BoundedInputStream.transferTo(java.io.OutputStream) -> org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
methodSources:
```java
@Override
public long transferTo(OutputStream out) throws IOException {
    // PATH: Test should invoke the next IOUtils.copy(...) [step in execution path]
    return IOUtils.copy(this, out);
}
```
constructors:
```java
public BoundedInputStream(long max, InputStream in) {
    this.max = max;
    this.in = in;
}
```
fieldDeclarations:
```java
private static final int EOF = -1;
private final long max;
private final InputStream in;
private long pos;
```
setters:
```java
@Override
public void mark(int readLimit) {
    in.mark(readLimit);
}

@Override
public void reset() throws IOException {
    in.reset();
    pos = 0;
}
```
imports: org.apache.commons.io.IOUtils

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.io
- class name MUST be: BoundedInputStreamtransferTo_IOUtilscopyFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/io/BoundedInputStreamtransferTo_IOUtilscopyFikaTest.java:[4,19] package org.mockito does not exist

================================================================================



====================================================================================================
TEST CASE 2/24 — ITERATION 5
Entry Point: org.apache.tika.io.BoundedInputStream.transferTo(java.io.OutputStream)
Third Party Method: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.io.BoundedInputStream.transferTo(java.io.OutputStream)
thirdPartyMethod: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
path: org.apache.tika.io.BoundedInputStream.transferTo(java.io.OutputStream) -> org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
methodSources:
```java
@Override
public long transferTo(OutputStream out) throws IOException {
    // PATH: Test should invoke the next IOUtils.copy(...) [step in execution path]
    return IOUtils.copy(this, out);
}
```
constructors:
```java
public BoundedInputStream(long max, InputStream in) {
    this.max = max;
    this.in = in;
}
```
fieldDeclarations:
```java
private static final int EOF = -1;
private final long max;
private final InputStream in;
private long pos;
```
setters:
```java
@Override
public void mark(int readLimit) {
    in.mark(readLimit);
}

@Override
public void reset() throws IOException {
    in.reset();
    pos = 0;
}
```
imports: org.apache.commons.io.IOUtils

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.io
- class name MUST be: BoundedInputStreamtransferTo_IOUtilscopyFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/io/BoundedInputStreamtransferTo_IOUtilscopyFikaTest.java:[4,19] package org.mockito does not exist

================================================================================



====================================================================================================
TEST CASE 3/24 — ITERATION 1
Entry Point: org.apache.tika.config.TikaActivator.start(org.osgi.framework.BundleContext)
Third Party Method: org.osgi.util.tracker.ServiceTracker.<init>(org.osgi.framework.BundleContext, java.lang.String, org.osgi.util.tracker.ServiceTrackerCustomizer)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.config.TikaActivator.start(org.osgi.framework.BundleContext)
thirdPartyMethod: org.osgi.util.tracker.ServiceTracker.<init>(org.osgi.framework.BundleContext, java.lang.String, org.osgi.util.tracker.ServiceTrackerCustomizer)
path: org.apache.tika.config.TikaActivator.start(org.osgi.framework.BundleContext) -> org.osgi.util.tracker.ServiceTracker.<init>(org.osgi.framework.BundleContext, java.lang.String, org.osgi.util.tracker.ServiceTrackerCustomizer)
methodSources:
```java
// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception // PATH: Test should invoke the next new ServiceTracker(...) [step in execution path]
{
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}
```
constructors:
```java
TikaActivator() {
}
```
fieldDeclarations:
```java
private ServiceTracker detectorTracker;
private ServiceTracker parserTracker;
private BundleContext bundleContext;
```
setters:
```java
public void removedService(ServiceReference reference, Object service) {
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}

// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception {
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}

public void stop(BundleContext context) throws Exception {
    parserTracker.close();
    detectorTracker.close();
}
```
imports: org.apache.tika.detect.Detector, org.apache.tika.parser.Parser, org.osgi.framework.BundleContext, org.osgi.framework.Constants, org.osgi.framework.ServiceReference, org.osgi.util.tracker.ServiceTracker

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.config
- class name MUST be: TikaActivatorstart_ServiceTrackermethodFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):



====================================================================================================
TEST CASE 3/24 — ITERATION 2
Entry Point: org.apache.tika.config.TikaActivator.start(org.osgi.framework.BundleContext)
Third Party Method: org.osgi.util.tracker.ServiceTracker.<init>(org.osgi.framework.BundleContext, java.lang.String, org.osgi.util.tracker.ServiceTrackerCustomizer)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.config.TikaActivator.start(org.osgi.framework.BundleContext)
thirdPartyMethod: org.osgi.util.tracker.ServiceTracker.<init>(org.osgi.framework.BundleContext, java.lang.String, org.osgi.util.tracker.ServiceTrackerCustomizer)
path: org.apache.tika.config.TikaActivator.start(org.osgi.framework.BundleContext) -> org.osgi.util.tracker.ServiceTracker.<init>(org.osgi.framework.BundleContext, java.lang.String, org.osgi.util.tracker.ServiceTrackerCustomizer)
methodSources:
```java
// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception // PATH: Test should invoke the next new ServiceTracker(...) [step in execution path]
{
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}
```
constructors:
```java
TikaActivator() {
}
```
fieldDeclarations:
```java
private ServiceTracker detectorTracker;
private ServiceTracker parserTracker;
private BundleContext bundleContext;
```
setters:
```java
public void removedService(ServiceReference reference, Object service) {
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}

// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception {
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}

public void stop(BundleContext context) throws Exception {
    parserTracker.close();
    detectorTracker.close();
}
```
imports: org.apache.tika.detect.Detector, org.apache.tika.parser.Parser, org.osgi.framework.BundleContext, org.osgi.framework.Constants, org.osgi.framework.ServiceReference, org.osgi.util.tracker.ServiceTracker

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.config
- class name MUST be: TikaActivatorstart_ServiceTrackermethodFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatorstart_ServiceTrackermethodFikaTest.java:[4,19] package org.mockito does not exist

================================================================================



====================================================================================================
TEST CASE 3/24 — ITERATION 3
Entry Point: org.apache.tika.config.TikaActivator.start(org.osgi.framework.BundleContext)
Third Party Method: org.osgi.util.tracker.ServiceTracker.<init>(org.osgi.framework.BundleContext, java.lang.String, org.osgi.util.tracker.ServiceTrackerCustomizer)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.config.TikaActivator.start(org.osgi.framework.BundleContext)
thirdPartyMethod: org.osgi.util.tracker.ServiceTracker.<init>(org.osgi.framework.BundleContext, java.lang.String, org.osgi.util.tracker.ServiceTrackerCustomizer)
path: org.apache.tika.config.TikaActivator.start(org.osgi.framework.BundleContext) -> org.osgi.util.tracker.ServiceTracker.<init>(org.osgi.framework.BundleContext, java.lang.String, org.osgi.util.tracker.ServiceTrackerCustomizer)
methodSources:
```java
// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception // PATH: Test should invoke the next new ServiceTracker(...) [step in execution path]
{
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}
```
constructors:
```java
TikaActivator() {
}
```
fieldDeclarations:
```java
private ServiceTracker detectorTracker;
private ServiceTracker parserTracker;
private BundleContext bundleContext;
```
setters:
```java
public void removedService(ServiceReference reference, Object service) {
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}

// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception {
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}

public void stop(BundleContext context) throws Exception {
    parserTracker.close();
    detectorTracker.close();
}
```
imports: org.apache.tika.detect.Detector, org.apache.tika.parser.Parser, org.osgi.framework.BundleContext, org.osgi.framework.Constants, org.osgi.framework.ServiceReference, org.osgi.util.tracker.ServiceTracker

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.config
- class name MUST be: TikaActivatorstart_ServiceTrackermethodFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatorstart_ServiceTrackermethodFikaTest.java:[4,19] package org.mockito does not exist

================================================================================



====================================================================================================
TEST CASE 3/24 — ITERATION 4
Entry Point: org.apache.tika.config.TikaActivator.start(org.osgi.framework.BundleContext)
Third Party Method: org.osgi.util.tracker.ServiceTracker.<init>(org.osgi.framework.BundleContext, java.lang.String, org.osgi.util.tracker.ServiceTrackerCustomizer)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.config.TikaActivator.start(org.osgi.framework.BundleContext)
thirdPartyMethod: org.osgi.util.tracker.ServiceTracker.<init>(org.osgi.framework.BundleContext, java.lang.String, org.osgi.util.tracker.ServiceTrackerCustomizer)
path: org.apache.tika.config.TikaActivator.start(org.osgi.framework.BundleContext) -> org.osgi.util.tracker.ServiceTracker.<init>(org.osgi.framework.BundleContext, java.lang.String, org.osgi.util.tracker.ServiceTrackerCustomizer)
methodSources:
```java
// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception // PATH: Test should invoke the next new ServiceTracker(...) [step in execution path]
{
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}
```
constructors:
```java
TikaActivator() {
}
```
fieldDeclarations:
```java
private ServiceTracker detectorTracker;
private ServiceTracker parserTracker;
private BundleContext bundleContext;
```
setters:
```java
public void removedService(ServiceReference reference, Object service) {
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}

// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception {
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}

public void stop(BundleContext context) throws Exception {
    parserTracker.close();
    detectorTracker.close();
}
```
imports: org.apache.tika.detect.Detector, org.apache.tika.parser.Parser, org.osgi.framework.BundleContext, org.osgi.framework.Constants, org.osgi.framework.ServiceReference, org.osgi.util.tracker.ServiceTracker

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.config
- class name MUST be: TikaActivatorstart_ServiceTrackermethodFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatorstart_ServiceTrackermethodFikaTest.java:[4,19] package org.mockito does not exist

================================================================================



====================================================================================================
TEST CASE 3/24 — ITERATION 5
Entry Point: org.apache.tika.config.TikaActivator.start(org.osgi.framework.BundleContext)
Third Party Method: org.osgi.util.tracker.ServiceTracker.<init>(org.osgi.framework.BundleContext, java.lang.String, org.osgi.util.tracker.ServiceTrackerCustomizer)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.config.TikaActivator.start(org.osgi.framework.BundleContext)
thirdPartyMethod: org.osgi.util.tracker.ServiceTracker.<init>(org.osgi.framework.BundleContext, java.lang.String, org.osgi.util.tracker.ServiceTrackerCustomizer)
path: org.apache.tika.config.TikaActivator.start(org.osgi.framework.BundleContext) -> org.osgi.util.tracker.ServiceTracker.<init>(org.osgi.framework.BundleContext, java.lang.String, org.osgi.util.tracker.ServiceTrackerCustomizer)
methodSources:
```java
// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception // PATH: Test should invoke the next new ServiceTracker(...) [step in execution path]
{
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}
```
constructors:
```java
TikaActivator() {
}
```
fieldDeclarations:
```java
private ServiceTracker detectorTracker;
private ServiceTracker parserTracker;
private BundleContext bundleContext;
```
setters:
```java
public void removedService(ServiceReference reference, Object service) {
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}

// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception {
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}

public void stop(BundleContext context) throws Exception {
    parserTracker.close();
    detectorTracker.close();
}
```
imports: org.apache.tika.detect.Detector, org.apache.tika.parser.Parser, org.osgi.framework.BundleContext, org.osgi.framework.Constants, org.osgi.framework.ServiceReference, org.osgi.util.tracker.ServiceTracker

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.config
- class name MUST be: TikaActivatorstart_ServiceTrackermethodFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatorstart_ServiceTrackermethodFikaTest.java:[4,19] package org.mockito does not exist

================================================================================



====================================================================================================
TEST CASE 4/24 — ITERATION 1
Entry Point: org.apache.tika.parser.NetworkParser.ParsingTask.run()
Third Party Method: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.parser.NetworkParser.ParsingTask.run()
thirdPartyMethod: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
path: org.apache.tika.parser.NetworkParser.ParsingTask.run() -> org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
methodSources:
```java
// ----------------------------------------------------------<Runnable>
public void run() {
    try {
        try // PATH: Test should invoke the next IOUtils.copy(...) [step in execution path]
        {
            IOUtils.copy(input, output);
        } finally {
            output.close();
        }
    } catch (Exception e) {
        exception = e;
    }
}
```
constructors:
```java
public ParsingTask(TikaInputStream input, OutputStream output) {
    this.input = input;
    this.output = output;
}
```
fieldDeclarations:
```java
private final TikaInputStream input;
private final OutputStream output;
private volatile Exception exception = null;
```
setters:
```java
public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {
    Thread thread = new Thread(this, "Tika network parser");
    thread.start();
    TaggedContentHandler tagged = new TaggedContentHandler(handler);
    try {
        XMLReaderUtils.parseSAX(stream, new TeeContentHandler(tagged, new MetaHandler(metadata)), context);
    } catch (SAXException e) {
        tagged.throwIfCauseOf(e);
        throw new TikaException("Invalid network parser output", e);
    } catch (IOException e) {
        throw new TikaException("Unable to read network parser output", e);
    } finally {
        try {
            thread.join(1000);
        } catch (InterruptedException e) {
            throw new TikaException("Network parser interrupted", e);
        }
        if (exception != null) {
            input.throwIfCauseOf(exception);
            throw new TikaException("Unexpected network parser error", exception);
        }
    }
}

// ----------------------------------------------------------<Runnable>
public void run() {
    try {
        try {
            IOUtils.copy(input, output);
        } finally {
            output.close();
        }
    } catch (Exception e) {
        exception = e;
    }
}
```
imports: org.apache.commons.io.IOUtils, org.apache.commons.io.input.TaggedInputStream, org.apache.tika.exception.TikaException, org.apache.tika.io.TikaInputStream, org.apache.tika.metadata.Metadata, org.apache.tika.parser.NetworkParser.MetaHandler, org.apache.tika.parser.NetworkParser.ParsingTask, org.apache.tika.sax.TaggedContentHandler, org.apache.tika.sax.TeeContentHandler, org.apache.tika.utils.XMLReaderUtils, org.xml.sax.ContentHandler, org.xml.sax.SAXException

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.parser
- class name MUST be: ParsingTaskrun_IOUtilscopyFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):



====================================================================================================
TEST CASE 4/24 — ITERATION 2
Entry Point: org.apache.tika.parser.NetworkParser.ParsingTask.run()
Third Party Method: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.parser.NetworkParser.ParsingTask.run()
thirdPartyMethod: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
path: org.apache.tika.parser.NetworkParser.ParsingTask.run() -> org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
methodSources:
```java
// ----------------------------------------------------------<Runnable>
public void run() {
    try {
        try // PATH: Test should invoke the next IOUtils.copy(...) [step in execution path]
        {
            IOUtils.copy(input, output);
        } finally {
            output.close();
        }
    } catch (Exception e) {
        exception = e;
    }
}
```
constructors:
```java
public ParsingTask(TikaInputStream input, OutputStream output) {
    this.input = input;
    this.output = output;
}
```
fieldDeclarations:
```java
private final TikaInputStream input;
private final OutputStream output;
private volatile Exception exception = null;
```
setters:
```java
public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {
    Thread thread = new Thread(this, "Tika network parser");
    thread.start();
    TaggedContentHandler tagged = new TaggedContentHandler(handler);
    try {
        XMLReaderUtils.parseSAX(stream, new TeeContentHandler(tagged, new MetaHandler(metadata)), context);
    } catch (SAXException e) {
        tagged.throwIfCauseOf(e);
        throw new TikaException("Invalid network parser output", e);
    } catch (IOException e) {
        throw new TikaException("Unable to read network parser output", e);
    } finally {
        try {
            thread.join(1000);
        } catch (InterruptedException e) {
            throw new TikaException("Network parser interrupted", e);
        }
        if (exception != null) {
            input.throwIfCauseOf(exception);
            throw new TikaException("Unexpected network parser error", exception);
        }
    }
}

// ----------------------------------------------------------<Runnable>
public void run() {
    try {
        try {
            IOUtils.copy(input, output);
        } finally {
            output.close();
        }
    } catch (Exception e) {
        exception = e;
    }
}
```
imports: org.apache.commons.io.IOUtils, org.apache.commons.io.input.TaggedInputStream, org.apache.tika.exception.TikaException, org.apache.tika.io.TikaInputStream, org.apache.tika.metadata.Metadata, org.apache.tika.parser.NetworkParser.MetaHandler, org.apache.tika.parser.NetworkParser.ParsingTask, org.apache.tika.sax.TaggedContentHandler, org.apache.tika.sax.TeeContentHandler, org.apache.tika.utils.XMLReaderUtils, org.xml.sax.ContentHandler, org.xml.sax.SAXException

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.parser
- class name MUST be: ParsingTaskrun_IOUtilscopyFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/parser/ParsingTaskrun_IOUtilscopyFikaTest.java:[17,22] org.apache.tika.parser.NetworkParser.ParsingTask has private access in org.apache.tika.parser.NetworkParser
[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/parser/ParsingTaskrun_IOUtilscopyFikaTest.java:[17,66] org.apache.tika.parser.NetworkParser.ParsingTask has private access in org.apache.tika.parser.NetworkParser

================================================================================



====================================================================================================
TEST CASE 4/24 — ITERATION 3
Entry Point: org.apache.tika.parser.NetworkParser.ParsingTask.run()
Third Party Method: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.parser.NetworkParser.ParsingTask.run()
thirdPartyMethod: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
path: org.apache.tika.parser.NetworkParser.ParsingTask.run() -> org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
methodSources:
```java
// ----------------------------------------------------------<Runnable>
public void run() {
    try {
        try // PATH: Test should invoke the next IOUtils.copy(...) [step in execution path]
        {
            IOUtils.copy(input, output);
        } finally {
            output.close();
        }
    } catch (Exception e) {
        exception = e;
    }
}
```
constructors:
```java
public ParsingTask(TikaInputStream input, OutputStream output) {
    this.input = input;
    this.output = output;
}
```
fieldDeclarations:
```java
private final TikaInputStream input;
private final OutputStream output;
private volatile Exception exception = null;
```
setters:
```java
public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {
    Thread thread = new Thread(this, "Tika network parser");
    thread.start();
    TaggedContentHandler tagged = new TaggedContentHandler(handler);
    try {
        XMLReaderUtils.parseSAX(stream, new TeeContentHandler(tagged, new MetaHandler(metadata)), context);
    } catch (SAXException e) {
        tagged.throwIfCauseOf(e);
        throw new TikaException("Invalid network parser output", e);
    } catch (IOException e) {
        throw new TikaException("Unable to read network parser output", e);
    } finally {
        try {
            thread.join(1000);
        } catch (InterruptedException e) {
            throw new TikaException("Network parser interrupted", e);
        }
        if (exception != null) {
            input.throwIfCauseOf(exception);
            throw new TikaException("Unexpected network parser error", exception);
        }
    }
}

// ----------------------------------------------------------<Runnable>
public void run() {
    try {
        try {
            IOUtils.copy(input, output);
        } finally {
            output.close();
        }
    } catch (Exception e) {
        exception = e;
    }
}
```
imports: org.apache.commons.io.IOUtils, org.apache.commons.io.input.TaggedInputStream, org.apache.tika.exception.TikaException, org.apache.tika.io.TikaInputStream, org.apache.tika.metadata.Metadata, org.apache.tika.parser.NetworkParser.MetaHandler, org.apache.tika.parser.NetworkParser.ParsingTask, org.apache.tika.sax.TaggedContentHandler, org.apache.tika.sax.TeeContentHandler, org.apache.tika.utils.XMLReaderUtils, org.xml.sax.ContentHandler, org.xml.sax.SAXException

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.parser
- class name MUST be: ParsingTaskrun_IOUtilscopyFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/parser/ParsingTaskrun_IOUtilscopyFikaTest.java:[19,22] org.apache.tika.parser.NetworkParser.ParsingTask has private access in org.apache.tika.parser.NetworkParser
[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/parser/ParsingTaskrun_IOUtilscopyFikaTest.java:[19,42] no suitable constructor found for NetworkParser(no arguments)

================================================================================



====================================================================================================
TEST CASE 4/24 — ITERATION 4
Entry Point: org.apache.tika.parser.NetworkParser.ParsingTask.run()
Third Party Method: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.parser.NetworkParser.ParsingTask.run()
thirdPartyMethod: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
path: org.apache.tika.parser.NetworkParser.ParsingTask.run() -> org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
methodSources:
```java
// ----------------------------------------------------------<Runnable>
public void run() {
    try {
        try // PATH: Test should invoke the next IOUtils.copy(...) [step in execution path]
        {
            IOUtils.copy(input, output);
        } finally {
            output.close();
        }
    } catch (Exception e) {
        exception = e;
    }
}
```
constructors:
```java
public ParsingTask(TikaInputStream input, OutputStream output) {
    this.input = input;
    this.output = output;
}
```
fieldDeclarations:
```java
private final TikaInputStream input;
private final OutputStream output;
private volatile Exception exception = null;
```
setters:
```java
public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {
    Thread thread = new Thread(this, "Tika network parser");
    thread.start();
    TaggedContentHandler tagged = new TaggedContentHandler(handler);
    try {
        XMLReaderUtils.parseSAX(stream, new TeeContentHandler(tagged, new MetaHandler(metadata)), context);
    } catch (SAXException e) {
        tagged.throwIfCauseOf(e);
        throw new TikaException("Invalid network parser output", e);
    } catch (IOException e) {
        throw new TikaException("Unable to read network parser output", e);
    } finally {
        try {
            thread.join(1000);
        } catch (InterruptedException e) {
            throw new TikaException("Network parser interrupted", e);
        }
        if (exception != null) {
            input.throwIfCauseOf(exception);
            throw new TikaException("Unexpected network parser error", exception);
        }
    }
}

// ----------------------------------------------------------<Runnable>
public void run() {
    try {
        try {
            IOUtils.copy(input, output);
        } finally {
            output.close();
        }
    } catch (Exception e) {
        exception = e;
    }
}
```
imports: org.apache.commons.io.IOUtils, org.apache.commons.io.input.TaggedInputStream, org.apache.tika.exception.TikaException, org.apache.tika.io.TikaInputStream, org.apache.tika.metadata.Metadata, org.apache.tika.parser.NetworkParser.MetaHandler, org.apache.tika.parser.NetworkParser.ParsingTask, org.apache.tika.sax.TaggedContentHandler, org.apache.tika.sax.TeeContentHandler, org.apache.tika.utils.XMLReaderUtils, org.xml.sax.ContentHandler, org.xml.sax.SAXException

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.parser
- class name MUST be: ParsingTaskrun_IOUtilscopyFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/parser/ParsingTaskrun_IOUtilscopyFikaTest.java:[19,22] org.apache.tika.parser.NetworkParser.ParsingTask has private access in org.apache.tika.parser.NetworkParser
[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/parser/ParsingTaskrun_IOUtilscopyFikaTest.java:[19,49] no suitable constructor found for NetworkParser(no arguments)

================================================================================



====================================================================================================
TEST CASE 4/24 — ITERATION 5
Entry Point: org.apache.tika.parser.NetworkParser.ParsingTask.run()
Third Party Method: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.parser.NetworkParser.ParsingTask.run()
thirdPartyMethod: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
path: org.apache.tika.parser.NetworkParser.ParsingTask.run() -> org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
methodSources:
```java
// ----------------------------------------------------------<Runnable>
public void run() {
    try {
        try // PATH: Test should invoke the next IOUtils.copy(...) [step in execution path]
        {
            IOUtils.copy(input, output);
        } finally {
            output.close();
        }
    } catch (Exception e) {
        exception = e;
    }
}
```
constructors:
```java
public ParsingTask(TikaInputStream input, OutputStream output) {
    this.input = input;
    this.output = output;
}
```
fieldDeclarations:
```java
private final TikaInputStream input;
private final OutputStream output;
private volatile Exception exception = null;
```
setters:
```java
public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {
    Thread thread = new Thread(this, "Tika network parser");
    thread.start();
    TaggedContentHandler tagged = new TaggedContentHandler(handler);
    try {
        XMLReaderUtils.parseSAX(stream, new TeeContentHandler(tagged, new MetaHandler(metadata)), context);
    } catch (SAXException e) {
        tagged.throwIfCauseOf(e);
        throw new TikaException("Invalid network parser output", e);
    } catch (IOException e) {
        throw new TikaException("Unable to read network parser output", e);
    } finally {
        try {
            thread.join(1000);
        } catch (InterruptedException e) {
            throw new TikaException("Network parser interrupted", e);
        }
        if (exception != null) {
            input.throwIfCauseOf(exception);
            throw new TikaException("Unexpected network parser error", exception);
        }
    }
}

// ----------------------------------------------------------<Runnable>
public void run() {
    try {
        try {
            IOUtils.copy(input, output);
        } finally {
            output.close();
        }
    } catch (Exception e) {
        exception = e;
    }
}
```
imports: org.apache.commons.io.IOUtils, org.apache.commons.io.input.TaggedInputStream, org.apache.tika.exception.TikaException, org.apache.tika.io.TikaInputStream, org.apache.tika.metadata.Metadata, org.apache.tika.parser.NetworkParser.MetaHandler, org.apache.tika.parser.NetworkParser.ParsingTask, org.apache.tika.sax.TaggedContentHandler, org.apache.tika.sax.TeeContentHandler, org.apache.tika.utils.XMLReaderUtils, org.xml.sax.ContentHandler, org.xml.sax.SAXException

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.parser
- class name MUST be: ParsingTaskrun_IOUtilscopyFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/parser/ParsingTaskrun_IOUtilscopyFikaTest.java:[19,22] org.apache.tika.parser.NetworkParser.ParsingTask has private access in org.apache.tika.parser.NetworkParser
[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/parser/ParsingTaskrun_IOUtilscopyFikaTest.java:[19,42] no suitable constructor found for NetworkParser(no arguments)

================================================================================



====================================================================================================
TEST CASE 5/24 — ITERATION 1
Entry Point: org.apache.tika.io.FileSource.skip(long)
Third Party Method: org.apache.commons.io.IOUtils.skip(java.io.InputStream, long)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.io.FileSource.skip(long)
thirdPartyMethod: org.apache.commons.io.IOUtils.skip(java.io.InputStream, long)
path: org.apache.tika.io.FileSource.skip(long) -> org.apache.commons.io.IOUtils.skip(java.io.InputStream, long)
methodSources:
```java
@Override
public long skip(long n) throws IOException {
    // PATH: Test should invoke the next IOUtils.skip(...) [step in execution path]
    long skipped = IOUtils.skip(currentStream, n);
    position += skipped;
    return skipped;
}
```
constructors:
```java
FileSource(Path path) throws IOException {
    this.path = path;
    this.length = Files.size(path);
    this.currentStream = new BufferedInputStream(Files.newInputStream(path));
    this.position = 0;
}
```
fieldDeclarations:
```java
private final Path path;
private final long length;
private InputStream currentStream;
private long position;
// Mark/reset support using seekTo
private long markPosition = -1;
```
setters:
```java
@Override
public void close() throws IOException {
    if (currentStream != null) {
        currentStream.close();
    }
}

@Override
public synchronized void mark(int readlimit) {
    markPosition = position;
}

@Override
public void seekTo(long newPosition) throws IOException {
    if (newPosition < 0) {
        throw new IOException("Cannot seek to negative position: " + newPosition);
    }
    if (newPosition > length) {
        throw new IOException((("Cannot seek past end of file. Position: " + newPosition) + ", length: ") + length);
    }
    // Close current stream and reopen at the beginning
    currentStream.close();
    currentStream = new BufferedInputStream(Files.newInputStream(path));
    // Skip to the new position
    if (newPosition > 0) {
        IOUtils.skipFully(currentStream, newPosition);
    }
    this.position = newPosition;
}
```
imports: org.apache.commons.io.IOUtils

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.io
- class name MUST be: FileSourceskip_IOUtilsskipFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):



====================================================================================================
TEST CASE 6/24 — ITERATION 1
Entry Point: org.apache.tika.config.TikaActivator.removedService(org.osgi.framework.ServiceReference, java.lang.Object)
Third Party Method: org.osgi.framework.BundleContext.ungetService(org.osgi.framework.ServiceReference)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.config.TikaActivator.removedService(org.osgi.framework.ServiceReference, java.lang.Object)
thirdPartyMethod: org.osgi.framework.BundleContext.ungetService(org.osgi.framework.ServiceReference)
path: org.apache.tika.config.TikaActivator.removedService(org.osgi.framework.ServiceReference, java.lang.Object) -> org.osgi.framework.BundleContext.ungetService(org.osgi.framework.ServiceReference)
methodSources:
```java
public void removedService(ServiceReference reference, Object service) // PATH: Test should invoke the next BundleContext.ungetService(...) [step in execution path]
{
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}
```
constructors:
```java
TikaActivator() {
}
```
fieldDeclarations:
```java
private ServiceTracker detectorTracker;
private ServiceTracker parserTracker;
private BundleContext bundleContext;
```
setters:
```java
public void removedService(ServiceReference reference, Object service) {
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}

// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception {
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}

public void stop(BundleContext context) throws Exception {
    parserTracker.close();
    detectorTracker.close();
}
```
imports: org.apache.tika.detect.Detector, org.apache.tika.parser.Parser, org.osgi.framework.BundleContext, org.osgi.framework.Constants, org.osgi.framework.ServiceReference, org.osgi.util.tracker.ServiceTracker

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.config
- class name MUST be: TikaActivatorremovedService_BundleContextungetServiceFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):



====================================================================================================
TEST CASE 6/24 — ITERATION 2
Entry Point: org.apache.tika.config.TikaActivator.removedService(org.osgi.framework.ServiceReference, java.lang.Object)
Third Party Method: org.osgi.framework.BundleContext.ungetService(org.osgi.framework.ServiceReference)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.config.TikaActivator.removedService(org.osgi.framework.ServiceReference, java.lang.Object)
thirdPartyMethod: org.osgi.framework.BundleContext.ungetService(org.osgi.framework.ServiceReference)
path: org.apache.tika.config.TikaActivator.removedService(org.osgi.framework.ServiceReference, java.lang.Object) -> org.osgi.framework.BundleContext.ungetService(org.osgi.framework.ServiceReference)
methodSources:
```java
public void removedService(ServiceReference reference, Object service) // PATH: Test should invoke the next BundleContext.ungetService(...) [step in execution path]
{
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}
```
constructors:
```java
TikaActivator() {
}
```
fieldDeclarations:
```java
private ServiceTracker detectorTracker;
private ServiceTracker parserTracker;
private BundleContext bundleContext;
```
setters:
```java
public void removedService(ServiceReference reference, Object service) {
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}

// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception {
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}

public void stop(BundleContext context) throws Exception {
    parserTracker.close();
    detectorTracker.close();
}
```
imports: org.apache.tika.detect.Detector, org.apache.tika.parser.Parser, org.osgi.framework.BundleContext, org.osgi.framework.Constants, org.osgi.framework.ServiceReference, org.osgi.util.tracker.ServiceTracker

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.config
- class name MUST be: TikaActivatorremovedService_BundleContextungetServiceFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatorremovedService_BundleContextungetServiceFikaTest.java:[10,26] package org.mockito does not exist
[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatorremovedService_BundleContextungetServiceFikaTest.java:[10,1] static import only from classes and interfaces

================================================================================



====================================================================================================
TEST CASE 6/24 — ITERATION 3
Entry Point: org.apache.tika.config.TikaActivator.removedService(org.osgi.framework.ServiceReference, java.lang.Object)
Third Party Method: org.osgi.framework.BundleContext.ungetService(org.osgi.framework.ServiceReference)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.config.TikaActivator.removedService(org.osgi.framework.ServiceReference, java.lang.Object)
thirdPartyMethod: org.osgi.framework.BundleContext.ungetService(org.osgi.framework.ServiceReference)
path: org.apache.tika.config.TikaActivator.removedService(org.osgi.framework.ServiceReference, java.lang.Object) -> org.osgi.framework.BundleContext.ungetService(org.osgi.framework.ServiceReference)
methodSources:
```java
public void removedService(ServiceReference reference, Object service) // PATH: Test should invoke the next BundleContext.ungetService(...) [step in execution path]
{
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}
```
constructors:
```java
TikaActivator() {
}
```
fieldDeclarations:
```java
private ServiceTracker detectorTracker;
private ServiceTracker parserTracker;
private BundleContext bundleContext;
```
setters:
```java
public void removedService(ServiceReference reference, Object service) {
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}

// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception {
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}

public void stop(BundleContext context) throws Exception {
    parserTracker.close();
    detectorTracker.close();
}
```
imports: org.apache.tika.detect.Detector, org.apache.tika.parser.Parser, org.osgi.framework.BundleContext, org.osgi.framework.Constants, org.osgi.framework.ServiceReference, org.osgi.util.tracker.ServiceTracker

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.config
- class name MUST be: TikaActivatorremovedService_BundleContextungetServiceFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatorremovedService_BundleContextungetServiceFikaTest.java:[4,19] package org.mockito does not exist

================================================================================



====================================================================================================
TEST CASE 6/24 — ITERATION 4
Entry Point: org.apache.tika.config.TikaActivator.removedService(org.osgi.framework.ServiceReference, java.lang.Object)
Third Party Method: org.osgi.framework.BundleContext.ungetService(org.osgi.framework.ServiceReference)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.config.TikaActivator.removedService(org.osgi.framework.ServiceReference, java.lang.Object)
thirdPartyMethod: org.osgi.framework.BundleContext.ungetService(org.osgi.framework.ServiceReference)
path: org.apache.tika.config.TikaActivator.removedService(org.osgi.framework.ServiceReference, java.lang.Object) -> org.osgi.framework.BundleContext.ungetService(org.osgi.framework.ServiceReference)
methodSources:
```java
public void removedService(ServiceReference reference, Object service) // PATH: Test should invoke the next BundleContext.ungetService(...) [step in execution path]
{
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}
```
constructors:
```java
TikaActivator() {
}
```
fieldDeclarations:
```java
private ServiceTracker detectorTracker;
private ServiceTracker parserTracker;
private BundleContext bundleContext;
```
setters:
```java
public void removedService(ServiceReference reference, Object service) {
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}

// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception {
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}

public void stop(BundleContext context) throws Exception {
    parserTracker.close();
    detectorTracker.close();
}
```
imports: org.apache.tika.detect.Detector, org.apache.tika.parser.Parser, org.osgi.framework.BundleContext, org.osgi.framework.Constants, org.osgi.framework.ServiceReference, org.osgi.util.tracker.ServiceTracker

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.config
- class name MUST be: TikaActivatorremovedService_BundleContextungetServiceFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatorremovedService_BundleContextungetServiceFikaTest.java:[4,19] package org.mockito does not exist

================================================================================



====================================================================================================
TEST CASE 6/24 — ITERATION 5
Entry Point: org.apache.tika.config.TikaActivator.removedService(org.osgi.framework.ServiceReference, java.lang.Object)
Third Party Method: org.osgi.framework.BundleContext.ungetService(org.osgi.framework.ServiceReference)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.config.TikaActivator.removedService(org.osgi.framework.ServiceReference, java.lang.Object)
thirdPartyMethod: org.osgi.framework.BundleContext.ungetService(org.osgi.framework.ServiceReference)
path: org.apache.tika.config.TikaActivator.removedService(org.osgi.framework.ServiceReference, java.lang.Object) -> org.osgi.framework.BundleContext.ungetService(org.osgi.framework.ServiceReference)
methodSources:
```java
public void removedService(ServiceReference reference, Object service) // PATH: Test should invoke the next BundleContext.ungetService(...) [step in execution path]
{
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}
```
constructors:
```java
TikaActivator() {
}
```
fieldDeclarations:
```java
private ServiceTracker detectorTracker;
private ServiceTracker parserTracker;
private BundleContext bundleContext;
```
setters:
```java
public void removedService(ServiceReference reference, Object service) {
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}

// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception {
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}

public void stop(BundleContext context) throws Exception {
    parserTracker.close();
    detectorTracker.close();
}
```
imports: org.apache.tika.detect.Detector, org.apache.tika.parser.Parser, org.osgi.framework.BundleContext, org.osgi.framework.Constants, org.osgi.framework.ServiceReference, org.osgi.util.tracker.ServiceTracker

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.config
- class name MUST be: TikaActivatorremovedService_BundleContextungetServiceFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatorremovedService_BundleContextungetServiceFikaTest.java:[4,19] package org.mockito does not exist

================================================================================



====================================================================================================
TEST CASE 7/24 — ITERATION 1
Entry Point: org.apache.tika.config.TikaActivator.stop(org.osgi.framework.BundleContext)
Third Party Method: org.osgi.util.tracker.ServiceTracker.close()
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.config.TikaActivator.stop(org.osgi.framework.BundleContext)
thirdPartyMethod: org.osgi.util.tracker.ServiceTracker.close()
path: org.apache.tika.config.TikaActivator.stop(org.osgi.framework.BundleContext) -> org.osgi.util.tracker.ServiceTracker.close()
methodSources:
```java
public void stop(BundleContext context) throws Exception // PATH: Test should invoke the next ServiceTracker.close(...) [step in execution path]
{
    parserTracker.close();
    detectorTracker.close();
}
```
constructors:
```java
TikaActivator() {
}
```
fieldDeclarations:
```java
private ServiceTracker detectorTracker;
private ServiceTracker parserTracker;
private BundleContext bundleContext;
```
setters:
```java
public void removedService(ServiceReference reference, Object service) {
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}

// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception {
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}

public void stop(BundleContext context) throws Exception {
    parserTracker.close();
    detectorTracker.close();
}
```
imports: org.apache.tika.detect.Detector, org.apache.tika.parser.Parser, org.osgi.framework.BundleContext, org.osgi.framework.Constants, org.osgi.framework.ServiceReference, org.osgi.util.tracker.ServiceTracker

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.config
- class name MUST be: TikaActivatorstop_ServiceTrackercloseFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):



====================================================================================================
TEST CASE 7/24 — ITERATION 2
Entry Point: org.apache.tika.config.TikaActivator.stop(org.osgi.framework.BundleContext)
Third Party Method: org.osgi.util.tracker.ServiceTracker.close()
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.config.TikaActivator.stop(org.osgi.framework.BundleContext)
thirdPartyMethod: org.osgi.util.tracker.ServiceTracker.close()
path: org.apache.tika.config.TikaActivator.stop(org.osgi.framework.BundleContext) -> org.osgi.util.tracker.ServiceTracker.close()
methodSources:
```java
public void stop(BundleContext context) throws Exception // PATH: Test should invoke the next ServiceTracker.close(...) [step in execution path]
{
    parserTracker.close();
    detectorTracker.close();
}
```
constructors:
```java
TikaActivator() {
}
```
fieldDeclarations:
```java
private ServiceTracker detectorTracker;
private ServiceTracker parserTracker;
private BundleContext bundleContext;
```
setters:
```java
public void removedService(ServiceReference reference, Object service) {
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}

// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception {
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}

public void stop(BundleContext context) throws Exception {
    parserTracker.close();
    detectorTracker.close();
}
```
imports: org.apache.tika.detect.Detector, org.apache.tika.parser.Parser, org.osgi.framework.BundleContext, org.osgi.framework.Constants, org.osgi.framework.ServiceReference, org.osgi.util.tracker.ServiceTracker

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.config
- class name MUST be: TikaActivatorstop_ServiceTrackercloseFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatorstop_ServiceTrackercloseFikaTest.java:[4,19] package org.mockito does not exist

================================================================================



====================================================================================================
TEST CASE 7/24 — ITERATION 3
Entry Point: org.apache.tika.config.TikaActivator.stop(org.osgi.framework.BundleContext)
Third Party Method: org.osgi.util.tracker.ServiceTracker.close()
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.config.TikaActivator.stop(org.osgi.framework.BundleContext)
thirdPartyMethod: org.osgi.util.tracker.ServiceTracker.close()
path: org.apache.tika.config.TikaActivator.stop(org.osgi.framework.BundleContext) -> org.osgi.util.tracker.ServiceTracker.close()
methodSources:
```java
public void stop(BundleContext context) throws Exception // PATH: Test should invoke the next ServiceTracker.close(...) [step in execution path]
{
    parserTracker.close();
    detectorTracker.close();
}
```
constructors:
```java
TikaActivator() {
}
```
fieldDeclarations:
```java
private ServiceTracker detectorTracker;
private ServiceTracker parserTracker;
private BundleContext bundleContext;
```
setters:
```java
public void removedService(ServiceReference reference, Object service) {
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}

// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception {
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}

public void stop(BundleContext context) throws Exception {
    parserTracker.close();
    detectorTracker.close();
}
```
imports: org.apache.tika.detect.Detector, org.apache.tika.parser.Parser, org.osgi.framework.BundleContext, org.osgi.framework.Constants, org.osgi.framework.ServiceReference, org.osgi.util.tracker.ServiceTracker

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.config
- class name MUST be: TikaActivatorstop_ServiceTrackercloseFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatorstop_ServiceTrackercloseFikaTest.java:[8,19] package org.mockito does not exist

================================================================================



====================================================================================================
TEST CASE 7/24 — ITERATION 4
Entry Point: org.apache.tika.config.TikaActivator.stop(org.osgi.framework.BundleContext)
Third Party Method: org.osgi.util.tracker.ServiceTracker.close()
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.config.TikaActivator.stop(org.osgi.framework.BundleContext)
thirdPartyMethod: org.osgi.util.tracker.ServiceTracker.close()
path: org.apache.tika.config.TikaActivator.stop(org.osgi.framework.BundleContext) -> org.osgi.util.tracker.ServiceTracker.close()
methodSources:
```java
public void stop(BundleContext context) throws Exception // PATH: Test should invoke the next ServiceTracker.close(...) [step in execution path]
{
    parserTracker.close();
    detectorTracker.close();
}
```
constructors:
```java
TikaActivator() {
}
```
fieldDeclarations:
```java
private ServiceTracker detectorTracker;
private ServiceTracker parserTracker;
private BundleContext bundleContext;
```
setters:
```java
public void removedService(ServiceReference reference, Object service) {
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}

// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception {
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}

public void stop(BundleContext context) throws Exception {
    parserTracker.close();
    detectorTracker.close();
}
```
imports: org.apache.tika.detect.Detector, org.apache.tika.parser.Parser, org.osgi.framework.BundleContext, org.osgi.framework.Constants, org.osgi.framework.ServiceReference, org.osgi.util.tracker.ServiceTracker

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.config
- class name MUST be: TikaActivatorstop_ServiceTrackercloseFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatorstop_ServiceTrackercloseFikaTest.java:[4,19] package org.mockito does not exist

================================================================================



====================================================================================================
TEST CASE 7/24 — ITERATION 5
Entry Point: org.apache.tika.config.TikaActivator.stop(org.osgi.framework.BundleContext)
Third Party Method: org.osgi.util.tracker.ServiceTracker.close()
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.config.TikaActivator.stop(org.osgi.framework.BundleContext)
thirdPartyMethod: org.osgi.util.tracker.ServiceTracker.close()
path: org.apache.tika.config.TikaActivator.stop(org.osgi.framework.BundleContext) -> org.osgi.util.tracker.ServiceTracker.close()
methodSources:
```java
public void stop(BundleContext context) throws Exception // PATH: Test should invoke the next ServiceTracker.close(...) [step in execution path]
{
    parserTracker.close();
    detectorTracker.close();
}
```
constructors:
```java
TikaActivator() {
}
```
fieldDeclarations:
```java
private ServiceTracker detectorTracker;
private ServiceTracker parserTracker;
private BundleContext bundleContext;
```
setters:
```java
public void removedService(ServiceReference reference, Object service) {
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}

// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception {
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}

public void stop(BundleContext context) throws Exception {
    parserTracker.close();
    detectorTracker.close();
}
```
imports: org.apache.tika.detect.Detector, org.apache.tika.parser.Parser, org.osgi.framework.BundleContext, org.osgi.framework.Constants, org.osgi.framework.ServiceReference, org.osgi.util.tracker.ServiceTracker

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.config
- class name MUST be: TikaActivatorstop_ServiceTrackercloseFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatorstop_ServiceTrackercloseFikaTest.java:[8,19] package org.mockito does not exist

================================================================================



====================================================================================================
TEST CASE 8/24 — ITERATION 1
Entry Point: org.apache.tika.io.TikaInputStream.skip(long)
Third Party Method: org.apache.commons.io.IOUtils.skip(java.io.InputStream, long)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.io.TikaInputStream.skip(long)
thirdPartyMethod: org.apache.commons.io.IOUtils.skip(java.io.InputStream, long)
path: org.apache.tika.io.TikaInputStream.skip(long) -> org.apache.commons.io.IOUtils.skip(java.io.InputStream, long)
methodSources:
```java
// ========== InputStream Methods ==========
/**
 * Skips up to {@code n} bytes. Returns the actual number of bytes skipped,
 * which may be less than requested if the end of stream is reached.
 * <p>
 * This method does NOT throw {@link java.io.EOFException} if fewer bytes
 * are available. Callers must check the return value to determine how many
 * bytes were actually skipped.
 *
 * @param n
 * 		the number of bytes to skip
 * @return the actual number of bytes skipped (may be less than {@code n})
 */
@Override
public long skip(long n) throws IOException {
    // PATH: Test should invoke the next IOUtils.skip(...) [step in execution path]
    long skipped = IOUtils.skip(in, n);
    position += skipped;
    return skipped;
}
```
constructors:
```java
// ========== Constructors ==========
/**
 * Protected constructor for subclasses.
 */
protected TikaInputStream(InputStream stream, long length) {
    super(stream);
    this.tmp = null;
}

/**
 * Strategy-based constructor.
 * TikaInputSource extends InputStream, so we pass it directly to super().
 */
private TikaInputStream(TikaInputSource inputSource, TemporaryResources tmp, String suffix) {
    super(((InputStream) (inputSource)));
    this.tmp = tmp;
    this.suffix = suffix;
}

public static TikaInputStream get(byte[] data) throws IOException {
    return get(data, new Metadata());
}

public static TikaInputStream get(byte[] data, Metadata metadata) throws IOException {
    metadata.set(Metadata.CONTENT_LENGTH, Integer.toString(data.length));
    String ext = getExtension(metadata);
    TemporaryResources tmp = new TemporaryResources();
    TikaInputSource inputSource = new ByteArraySource(data, tmp);
    return new TikaInputStream(inputSource, tmp, ext);
}

public static TikaInputStream get(File file) throws IOException {
    return get(file.toPath(), new Metadata());
}

public static TikaInputStream get(File file, Metadata metadata) throws IOException {
    return get(file.toPath(), metadata);
}

public static TikaInputStream get(InputStream stream) {
    return get(stream, new TemporaryResources(), null);
}

// ========== Static Factory Methods ==========
public static TikaInputStream get(InputStream stream, TemporaryResources tmp, Metadata metadata) {
    if (stream == null) {
        throw new NullPointerException("The Stream must not be null");
    }
    if (stream instanceof TikaInputStream) {
        return ((TikaInputStream) (stream));
    }
    String ext = getExtension(metadata);
    TikaInputSource inputSource = new CachingSource(stream, tmp, -1, metadata);
    return new TikaInputStream(inputSource, tmp, ext);
}

public static TikaInputStream get(InputStream stream, Metadata metadata) {
    return get(stream, new TemporaryResources(), metadata);
}

public static TikaInputStream get(URI uri) throws IOException {
    return get(uri, new Metadata());
}

public static TikaInputStream get(URI uri, Metadata metadata) throws IOException {
    if ("file".equalsIgnoreCase(uri.getScheme())) {
        Path path = Paths.get(uri);
        if (Files.isRegularFile(path)) {
            return get(path, metadata);
        }
    }
    return get(uri.toURL(), metadata);
}

public static TikaInputStream get(URL url) throws IOException {
    return get(url, new Metadata());
}

public static TikaInputStream get(URL url, Metadata metadata) throws IOException {
    if ("file".equalsIgnoreCase(url.getProtocol())) {
        try {
            Path path = Paths.get(url.toURI());
            if (Files.isRegularFile(path)) {
                return get(path, metadata);
            }
        } catch (URISyntaxException e) {
            // fall through
        }
    }
    URLConnection connection = url.openConnection();
    String urlPath = url.getPath();
    int slash = urlPath.lastIndexOf('/');
    if ((slash + 1) < urlPath.length()) {
        metadata.set(TikaCoreProperties.RESOURCE_NAME_KEY, urlPath.substring(slash + 1));
    }
    String type = connection.getContentType();
    if (type != null) {
        metadata.set(Metadata.CONTENT_TYPE, type);
    }
    String encoding = connection.getContentEncoding();
    if (encoding != null) {
        metadata.set(Metadata.CONTENT_ENCODING, encoding);
    }
    int length = connection.getContentLength();
    if (length >= 0) {
        metadata.set(Metadata.CONTENT_LENGTH, Integer.toString(length));
    }
    String ext = getExtension(metadata);
    TemporaryResources tmp = new TemporaryResources();
    TikaInputSource inputSource = new CachingSource(new BufferedInputStream(connection.getInputStream()), tmp, length, metadata);
    return new TikaInputStream(inputSource, tmp, ext);
}

public static TikaInputStream get(Path path) throws IOException {
    return get(path, new Metadata());
}

public static TikaInputStream get(Path path, Metadata metadata) throws IOException {
    if (StringUtils.isBlank(metadata.get(TikaCoreProperties.RESOURCE_NAME_KEY))) {
        metadata.set(TikaCoreProperties.RESOURCE_NAME_KEY, path.getFileName().toString());
    }
    metadata.set(Metadata.CONTENT_LENGTH, Long.toString(Files.size(path)));
    String ext = FilenameUtils.getSuffixFromPath(path.getFileName().toString());
    TemporaryResources tmp = new TemporaryResources();
    TikaInputSource inputSource = new FileSource(path);
    return new TikaInputStream(inputSource, tmp, ext);
}

public static TikaInputStream get(Path path, Metadata metadata, TemporaryResources tmp) throws IOException {
    long length = Files.size(path);
    if (StringUtils.isBlank(metadata.get(TikaCoreProperties.RESOURCE_NAME_KEY))) {
        metadata.set(TikaCoreProperties.RESOURCE_NAME_KEY, path.getFileName().toString());
    }
    metadata.set(Metadata.CONTENT_LENGTH, Long.toString(length));
    String ext = FilenameUtils.getSuffixFromPath(path.getFileName().toString());
    TikaInputSource inputSource = new FileSource(path);
    return new TikaInputStream(inputSource, tmp, ext);
}

public static TikaInputStream get(Blob blob) throws SQLException, IOException {
    return get(blob, new Metadata());
}

public static TikaInputStream get(Blob blob, Metadata metadata) throws SQLException, IOException {
    long length = -1;
    try {
        length = blob.length();
        metadata.set(Metadata.CONTENT_LENGTH, Long.toString(length));
    } catch (SQLException ignore) {
    }
    if ((0 <= length) && (length <= BLOB_SIZE_THRESHOLD)) {
        return get(blob.getBytes(1, ((int) (length))), metadata);
    } else {
        String ext = getExtension(metadata);
        TemporaryResources tmp = new TemporaryResources();
        TikaInputSource inputSource = new CachingSource(new BufferedInputStream(blob.getBinaryStream()), tmp, length, metadata);
        return new TikaInputStream(inputSource, tmp, ext);
    }
}

public static TikaInputStream getFromContainer(Object openContainer, long length, Metadata metadata) throws IOException {
    TikaInputStream tis = TikaInputStream.get(new byte[0], metadata);
    tis.setOpenContainer(openContainer);
    tis.setLength(length);
    metadata.set(Metadata.CONTENT_LENGTH, Long.toString(length));
    return tis;
}
```
fieldDeclarations:
```java
private static final int MAX_CONSECUTIVE_EOFS = 1000;
private static final int BLOB_SIZE_THRESHOLD = 1024 * 1024;
protected TemporaryResources tmp;
private long position = 0;
private long mark = -1;
private Object openContainer;
private int consecutiveEOFs = 0;
private int closeShieldDepth = 0;
private String suffix = null;
private long overrideLength = -1;// For getFromContainer() to set explicit length

```
setters:
```java
public void addCloseableResource(Closeable closeable) {
    tmp.addResource(closeable);
}

@Override
protected void afterRead(int n) throws IOException {
    if (n != (-1)) {
        position += n;
        consecutiveEOFs = 0;
    } else {
        consecutiveEOFs++;
        if (consecutiveEOFs > MAX_CONSECUTIVE_EOFS) {
            throw new IOException("Read too many -1 (EOFs); there could be an infinite loop. " + "If you think your file is not corrupt, please open an issue on Tika's JIRA");
        }
    }
}

@Override
public void close() throws IOException {
    if (closeShieldDepth > 0) {
        return;
    }
    mark = -1;
    if (tmp != null) {
        tmp.addResource(in);
        tmp.close();
    }
}

@Override
public void mark(int readlimit) {
    super.mark(readlimit);
    mark = position;
}

@Override
public void reset() throws IOException {
    if (mark < 0) {
        throw new IOException("Resetting to invalid mark");
    }
    // Delegate to underlying stream's reset (handles passthrough and caching modes)
    super.reset();
    position = mark;
    // Don't invalidate mark - allow multiple reset() calls to same mark
    consecutiveEOFs = 0;
}

/**
 * Rewind the stream to the beginning.
 * <p>
 * For streams created from byte arrays or files, this always works.
 * For streams created from raw InputStreams, this requires
 * {@link #enableRewind()} to have been called first.
 */
public void rewind() throws IOException {
    TikaInputSource source = inputSource();
    if (source != null) {
        source.seekTo(0);
    } else {
        throw new IOException("Cannot rewind: no TikaInputSource available");
    }
    position = 0;
    mark = -1;
    consecutiveEOFs = 0;
}

private void setLength(long length) {
    this.overrideLength = length;
}

public void setOpenContainer(Object container) {
    openContainer = container;
    if (container instanceof Closeable) {
        tmp.addResource(((Closeable) (container)));
    }
}

protected void setPosition(long position) {
    this.position = position;
}
```
imports: org.apache.commons.io.IOUtils, org.apache.commons.io.input.ProxyInputStream, org.apache.commons.io.input.TaggedInputStream

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.io
- class name MUST be: TikaInputStreamskip_IOUtilsskipFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):



====================================================================================================
TEST CASE 9/24 — ITERATION 1
Entry Point: org.apache.tika.parser.NetworkParser.parse(org.apache.tika.io.TikaInputStream, org.xml.sax.ContentHandler, org.apache.tika.metadata.Metadata, org.apache.tika.parser.ParseContext)
Third Party Method: org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.parser.NetworkParser.parse(org.apache.tika.io.TikaInputStream, org.xml.sax.ContentHandler, org.apache.tika.metadata.Metadata, org.apache.tika.parser.ParseContext)
thirdPartyMethod: org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
path: org.apache.tika.parser.NetworkParser.parse(org.apache.tika.io.TikaInputStream, org.xml.sax.ContentHandler, org.apache.tika.metadata.Metadata, org.apache.tika.parser.ParseContext) -> org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
methodSources:
```java
public void parse(TikaInputStream tis, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {
    if ("telnet".equals(uri.getScheme())) {
        try (Socket socket = new Socket(uri.getHost(), uri.getPort())) {
            new ParsingTask(tis, new FilterOutputStream(socket.getOutputStream()) {
                @Override
                public void close() throws IOException {
                    socket.shutdownOutput();
                }
            }).parse(socket.getInputStream(), handler, metadata, context);
        }
    } else {
        URL url = uri.toURL();
        URLConnection connection = url.openConnection();
        connection.setDoOutput(true);
        connection.connect();
        try (InputStream input = connection.getInputStream()) {
            // PATH: Test should invoke the next CloseShieldInputStream.wrap(...) [step in execution path]
            new ParsingTask(tis, connection.getOutputStream()).parse(CloseShieldInputStream.wrap(input), handler, metadata, context);
        }
    }
}
```
constructors:
```java
public NetworkParser(URI uri, Set<MediaType> supportedTypes) {
    this.uri = uri;
    this.supportedTypes = supportedTypes;
}

public NetworkParser(URI uri) {
    this(uri, Collections.singleton(MediaType.OCTET_STREAM));
}

1($anonymous0) {
}

public ParsingTask(TikaInputStream input, OutputStream output) {
    this.input = input;
    this.output = output;
}

public MetaHandler(Metadata metadata) {
    this.metadata = metadata;
}
```
fieldDeclarations:
```java
private final URI uri;
private final Set<MediaType> supportedTypes;
```
setters:
```java
public void parse(TikaInputStream tis, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {
    if ("telnet".equals(uri.getScheme())) {
        try (Socket socket = new Socket(uri.getHost(), uri.getPort())) {
            new ParsingTask(tis, new FilterOutputStream(socket.getOutputStream()) {
                @Override
                public void close() throws IOException {
                    socket.shutdownOutput();
                }
            }).parse(socket.getInputStream(), handler, metadata, context);
        }
    } else {
        URL url = uri.toURL();
        URLConnection connection = url.openConnection();
        connection.setDoOutput(true);
        connection.connect();
        try (InputStream input = connection.getInputStream()) {
            new ParsingTask(tis, connection.getOutputStream()).parse(CloseShieldInputStream.wrap(input), handler, metadata, context);
        }
    }
}
```
imports: org.apache.commons.io.input.CloseShieldInputStream, org.apache.tika.exception.TikaException, org.apache.tika.io.TikaInputStream, org.apache.tika.metadata.Metadata, org.apache.tika.mime.MediaType, org.apache.tika.parser.NetworkParser.MetaHandler, org.apache.tika.parser.NetworkParser.ParsingTask, org.xml.sax.ContentHandler, org.xml.sax.SAXException, org.xml.sax.helpers.DefaultHandler

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.parser
- class name MUST be: NetworkParserparse_CloseShieldInputStreamwrapFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):



====================================================================================================
TEST CASE 9/24 — ITERATION 2
Entry Point: org.apache.tika.parser.NetworkParser.parse(org.apache.tika.io.TikaInputStream, org.xml.sax.ContentHandler, org.apache.tika.metadata.Metadata, org.apache.tika.parser.ParseContext)
Third Party Method: org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.parser.NetworkParser.parse(org.apache.tika.io.TikaInputStream, org.xml.sax.ContentHandler, org.apache.tika.metadata.Metadata, org.apache.tika.parser.ParseContext)
thirdPartyMethod: org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
path: org.apache.tika.parser.NetworkParser.parse(org.apache.tika.io.TikaInputStream, org.xml.sax.ContentHandler, org.apache.tika.metadata.Metadata, org.apache.tika.parser.ParseContext) -> org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
methodSources:
```java
public void parse(TikaInputStream tis, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {
    if ("telnet".equals(uri.getScheme())) {
        try (Socket socket = new Socket(uri.getHost(), uri.getPort())) {
            new ParsingTask(tis, new FilterOutputStream(socket.getOutputStream()) {
                @Override
                public void close() throws IOException {
                    socket.shutdownOutput();
                }
            }).parse(socket.getInputStream(), handler, metadata, context);
        }
    } else {
        URL url = uri.toURL();
        URLConnection connection = url.openConnection();
        connection.setDoOutput(true);
        connection.connect();
        try (InputStream input = connection.getInputStream()) {
            // PATH: Test should invoke the next CloseShieldInputStream.wrap(...) [step in execution path]
            new ParsingTask(tis, connection.getOutputStream()).parse(CloseShieldInputStream.wrap(input), handler, metadata, context);
        }
    }
}
```
constructors:
```java
public NetworkParser(URI uri, Set<MediaType> supportedTypes) {
    this.uri = uri;
    this.supportedTypes = supportedTypes;
}

public NetworkParser(URI uri) {
    this(uri, Collections.singleton(MediaType.OCTET_STREAM));
}

1($anonymous0) {
}

public ParsingTask(TikaInputStream input, OutputStream output) {
    this.input = input;
    this.output = output;
}

public MetaHandler(Metadata metadata) {
    this.metadata = metadata;
}
```
fieldDeclarations:
```java
private final URI uri;
private final Set<MediaType> supportedTypes;
```
setters:
```java
public void parse(TikaInputStream tis, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {
    if ("telnet".equals(uri.getScheme())) {
        try (Socket socket = new Socket(uri.getHost(), uri.getPort())) {
            new ParsingTask(tis, new FilterOutputStream(socket.getOutputStream()) {
                @Override
                public void close() throws IOException {
                    socket.shutdownOutput();
                }
            }).parse(socket.getInputStream(), handler, metadata, context);
        }
    } else {
        URL url = uri.toURL();
        URLConnection connection = url.openConnection();
        connection.setDoOutput(true);
        connection.connect();
        try (InputStream input = connection.getInputStream()) {
            new ParsingTask(tis, connection.getOutputStream()).parse(CloseShieldInputStream.wrap(input), handler, metadata, context);
        }
    }
}
```
imports: org.apache.commons.io.input.CloseShieldInputStream, org.apache.tika.exception.TikaException, org.apache.tika.io.TikaInputStream, org.apache.tika.metadata.Metadata, org.apache.tika.mime.MediaType, org.apache.tika.parser.NetworkParser.MetaHandler, org.apache.tika.parser.NetworkParser.ParsingTask, org.xml.sax.ContentHandler, org.xml.sax.SAXException, org.xml.sax.helpers.DefaultHandler

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.parser
- class name MUST be: NetworkParserparse_CloseShieldInputStreamwrapFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
TEST FAILURES DETECTED
================================================================================

[ERROR] Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 1.059 s <<< FAILURE! -- in org.apache.tika.parser.NetworkParserparse_CloseShieldInputStreamwrapFikaTest
[ERROR] org.apache.tika.parser.NetworkParserparse_CloseShieldInputStreamwrapFikaTest.testParsePathToCloseShieldInputStreamWrap -- Time elapsed: 1.023 s <<< ERROR!
java.net.ProtocolException: Cannot write output after reading input.
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getOutputStream0(HttpURLConnection.java:1475)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getOutputStream(HttpURLConnection.java:1442)
	at org.apache.tika.parser.NetworkParser.parse(NetworkParser.java:82)
[ERROR] org.apache.tika.parser.NetworkParserparse_CloseShieldInputStreamwrapFikaTest.testParsePathToCloseShieldInputStreamWrap -- Time elapsed: 1.023 s <<< ERROR!
java.net.ProtocolException: Cannot write output after reading input.
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getOutputStream0(HttpURLConnection.java:1475)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getOutputStream(HttpURLConnection.java:1442)
	at org.apache.tika.parser.NetworkParser.parse(NetworkParser.java:82)
	at org.apache.tika.parser.NetworkParserparse_CloseShieldInputStreamwrapFikaTest.testParsePathToCloseShieldInputStreamWrap(NetworkParserparse_CloseShieldInputStreamwrapFikaTest.java:29)

================================================================================



====================================================================================================
TEST CASE 9/24 — ITERATION 3
Entry Point: org.apache.tika.parser.NetworkParser.parse(org.apache.tika.io.TikaInputStream, org.xml.sax.ContentHandler, org.apache.tika.metadata.Metadata, org.apache.tika.parser.ParseContext)
Third Party Method: org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.parser.NetworkParser.parse(org.apache.tika.io.TikaInputStream, org.xml.sax.ContentHandler, org.apache.tika.metadata.Metadata, org.apache.tika.parser.ParseContext)
thirdPartyMethod: org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
path: org.apache.tika.parser.NetworkParser.parse(org.apache.tika.io.TikaInputStream, org.xml.sax.ContentHandler, org.apache.tika.metadata.Metadata, org.apache.tika.parser.ParseContext) -> org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
methodSources:
```java
public void parse(TikaInputStream tis, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {
    if ("telnet".equals(uri.getScheme())) {
        try (Socket socket = new Socket(uri.getHost(), uri.getPort())) {
            new ParsingTask(tis, new FilterOutputStream(socket.getOutputStream()) {
                @Override
                public void close() throws IOException {
                    socket.shutdownOutput();
                }
            }).parse(socket.getInputStream(), handler, metadata, context);
        }
    } else {
        URL url = uri.toURL();
        URLConnection connection = url.openConnection();
        connection.setDoOutput(true);
        connection.connect();
        try (InputStream input = connection.getInputStream()) {
            // PATH: Test should invoke the next CloseShieldInputStream.wrap(...) [step in execution path]
            new ParsingTask(tis, connection.getOutputStream()).parse(CloseShieldInputStream.wrap(input), handler, metadata, context);
        }
    }
}
```
constructors:
```java
public NetworkParser(URI uri, Set<MediaType> supportedTypes) {
    this.uri = uri;
    this.supportedTypes = supportedTypes;
}

public NetworkParser(URI uri) {
    this(uri, Collections.singleton(MediaType.OCTET_STREAM));
}

1($anonymous0) {
}

public ParsingTask(TikaInputStream input, OutputStream output) {
    this.input = input;
    this.output = output;
}

public MetaHandler(Metadata metadata) {
    this.metadata = metadata;
}
```
fieldDeclarations:
```java
private final URI uri;
private final Set<MediaType> supportedTypes;
```
setters:
```java
public void parse(TikaInputStream tis, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {
    if ("telnet".equals(uri.getScheme())) {
        try (Socket socket = new Socket(uri.getHost(), uri.getPort())) {
            new ParsingTask(tis, new FilterOutputStream(socket.getOutputStream()) {
                @Override
                public void close() throws IOException {
                    socket.shutdownOutput();
                }
            }).parse(socket.getInputStream(), handler, metadata, context);
        }
    } else {
        URL url = uri.toURL();
        URLConnection connection = url.openConnection();
        connection.setDoOutput(true);
        connection.connect();
        try (InputStream input = connection.getInputStream()) {
            new ParsingTask(tis, connection.getOutputStream()).parse(CloseShieldInputStream.wrap(input), handler, metadata, context);
        }
    }
}
```
imports: org.apache.commons.io.input.CloseShieldInputStream, org.apache.tika.exception.TikaException, org.apache.tika.io.TikaInputStream, org.apache.tika.metadata.Metadata, org.apache.tika.mime.MediaType, org.apache.tika.parser.NetworkParser.MetaHandler, org.apache.tika.parser.NetworkParser.ParsingTask, org.xml.sax.ContentHandler, org.xml.sax.SAXException, org.xml.sax.helpers.DefaultHandler

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.parser
- class name MUST be: NetworkParserparse_CloseShieldInputStreamwrapFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/parser/NetworkParserparse_CloseShieldInputStreamwrapFikaTest.java:[8,44] org.apache.tika.parser.NetworkParser.MetaHandler has private access in org.apache.tika.parser.NetworkParser
[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/parser/NetworkParserparse_CloseShieldInputStreamwrapFikaTest.java:[9,44] org.apache.tika.parser.NetworkParser.ParsingTask has private access in org.apache.tika.parser.NetworkParser

================================================================================



====================================================================================================
TEST CASE 9/24 — ITERATION 4
Entry Point: org.apache.tika.parser.NetworkParser.parse(org.apache.tika.io.TikaInputStream, org.xml.sax.ContentHandler, org.apache.tika.metadata.Metadata, org.apache.tika.parser.ParseContext)
Third Party Method: org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.parser.NetworkParser.parse(org.apache.tika.io.TikaInputStream, org.xml.sax.ContentHandler, org.apache.tika.metadata.Metadata, org.apache.tika.parser.ParseContext)
thirdPartyMethod: org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
path: org.apache.tika.parser.NetworkParser.parse(org.apache.tika.io.TikaInputStream, org.xml.sax.ContentHandler, org.apache.tika.metadata.Metadata, org.apache.tika.parser.ParseContext) -> org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
methodSources:
```java
public void parse(TikaInputStream tis, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {
    if ("telnet".equals(uri.getScheme())) {
        try (Socket socket = new Socket(uri.getHost(), uri.getPort())) {
            new ParsingTask(tis, new FilterOutputStream(socket.getOutputStream()) {
                @Override
                public void close() throws IOException {
                    socket.shutdownOutput();
                }
            }).parse(socket.getInputStream(), handler, metadata, context);
        }
    } else {
        URL url = uri.toURL();
        URLConnection connection = url.openConnection();
        connection.setDoOutput(true);
        connection.connect();
        try (InputStream input = connection.getInputStream()) {
            // PATH: Test should invoke the next CloseShieldInputStream.wrap(...) [step in execution path]
            new ParsingTask(tis, connection.getOutputStream()).parse(CloseShieldInputStream.wrap(input), handler, metadata, context);
        }
    }
}
```
constructors:
```java
public NetworkParser(URI uri, Set<MediaType> supportedTypes) {
    this.uri = uri;
    this.supportedTypes = supportedTypes;
}

public NetworkParser(URI uri) {
    this(uri, Collections.singleton(MediaType.OCTET_STREAM));
}

1($anonymous0) {
}

public ParsingTask(TikaInputStream input, OutputStream output) {
    this.input = input;
    this.output = output;
}

public MetaHandler(Metadata metadata) {
    this.metadata = metadata;
}
```
fieldDeclarations:
```java
private final URI uri;
private final Set<MediaType> supportedTypes;
```
setters:
```java
public void parse(TikaInputStream tis, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {
    if ("telnet".equals(uri.getScheme())) {
        try (Socket socket = new Socket(uri.getHost(), uri.getPort())) {
            new ParsingTask(tis, new FilterOutputStream(socket.getOutputStream()) {
                @Override
                public void close() throws IOException {
                    socket.shutdownOutput();
                }
            }).parse(socket.getInputStream(), handler, metadata, context);
        }
    } else {
        URL url = uri.toURL();
        URLConnection connection = url.openConnection();
        connection.setDoOutput(true);
        connection.connect();
        try (InputStream input = connection.getInputStream()) {
            new ParsingTask(tis, connection.getOutputStream()).parse(CloseShieldInputStream.wrap(input), handler, metadata, context);
        }
    }
}
```
imports: org.apache.commons.io.input.CloseShieldInputStream, org.apache.tika.exception.TikaException, org.apache.tika.io.TikaInputStream, org.apache.tika.metadata.Metadata, org.apache.tika.mime.MediaType, org.apache.tika.parser.NetworkParser.MetaHandler, org.apache.tika.parser.NetworkParser.ParsingTask, org.xml.sax.ContentHandler, org.xml.sax.SAXException, org.xml.sax.helpers.DefaultHandler

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.parser
- class name MUST be: NetworkParserparse_CloseShieldInputStreamwrapFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
TEST FAILURES DETECTED
================================================================================

[ERROR] Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 0.942 s <<< FAILURE! -- in org.apache.tika.parser.NetworkParserparse_CloseShieldInputStreamwrapFikaTest
[ERROR] org.apache.tika.parser.NetworkParserparse_CloseShieldInputStreamwrapFikaTest.testParsePath -- Time elapsed: 0.881 s <<< ERROR!
java.io.FileNotFoundException: http://example.com/test
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:2048)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1641)
	at org.apache.tika.parser.NetworkParser.parse(NetworkParser.java:81)
[ERROR] org.apache.tika.parser.NetworkParserparse_CloseShieldInputStreamwrapFikaTest.testParsePath -- Time elapsed: 0.881 s <<< ERROR!
java.io.FileNotFoundException: http://example.com/test
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:2048)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1641)
	at org.apache.tika.parser.NetworkParser.parse(NetworkParser.java:81)
	at org.apache.tika.parser.NetworkParserparse_CloseShieldInputStreamwrapFikaTest.testParsePath(NetworkParserparse_CloseShieldInputStreamwrapFikaTest.java:30)

================================================================================



====================================================================================================
TEST CASE 9/24 — ITERATION 5
Entry Point: org.apache.tika.parser.NetworkParser.parse(org.apache.tika.io.TikaInputStream, org.xml.sax.ContentHandler, org.apache.tika.metadata.Metadata, org.apache.tika.parser.ParseContext)
Third Party Method: org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.parser.NetworkParser.parse(org.apache.tika.io.TikaInputStream, org.xml.sax.ContentHandler, org.apache.tika.metadata.Metadata, org.apache.tika.parser.ParseContext)
thirdPartyMethod: org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
path: org.apache.tika.parser.NetworkParser.parse(org.apache.tika.io.TikaInputStream, org.xml.sax.ContentHandler, org.apache.tika.metadata.Metadata, org.apache.tika.parser.ParseContext) -> org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
methodSources:
```java
public void parse(TikaInputStream tis, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {
    if ("telnet".equals(uri.getScheme())) {
        try (Socket socket = new Socket(uri.getHost(), uri.getPort())) {
            new ParsingTask(tis, new FilterOutputStream(socket.getOutputStream()) {
                @Override
                public void close() throws IOException {
                    socket.shutdownOutput();
                }
            }).parse(socket.getInputStream(), handler, metadata, context);
        }
    } else {
        URL url = uri.toURL();
        URLConnection connection = url.openConnection();
        connection.setDoOutput(true);
        connection.connect();
        try (InputStream input = connection.getInputStream()) {
            // PATH: Test should invoke the next CloseShieldInputStream.wrap(...) [step in execution path]
            new ParsingTask(tis, connection.getOutputStream()).parse(CloseShieldInputStream.wrap(input), handler, metadata, context);
        }
    }
}
```
constructors:
```java
public NetworkParser(URI uri, Set<MediaType> supportedTypes) {
    this.uri = uri;
    this.supportedTypes = supportedTypes;
}

public NetworkParser(URI uri) {
    this(uri, Collections.singleton(MediaType.OCTET_STREAM));
}

1($anonymous0) {
}

public ParsingTask(TikaInputStream input, OutputStream output) {
    this.input = input;
    this.output = output;
}

public MetaHandler(Metadata metadata) {
    this.metadata = metadata;
}
```
fieldDeclarations:
```java
private final URI uri;
private final Set<MediaType> supportedTypes;
```
setters:
```java
public void parse(TikaInputStream tis, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {
    if ("telnet".equals(uri.getScheme())) {
        try (Socket socket = new Socket(uri.getHost(), uri.getPort())) {
            new ParsingTask(tis, new FilterOutputStream(socket.getOutputStream()) {
                @Override
                public void close() throws IOException {
                    socket.shutdownOutput();
                }
            }).parse(socket.getInputStream(), handler, metadata, context);
        }
    } else {
        URL url = uri.toURL();
        URLConnection connection = url.openConnection();
        connection.setDoOutput(true);
        connection.connect();
        try (InputStream input = connection.getInputStream()) {
            new ParsingTask(tis, connection.getOutputStream()).parse(CloseShieldInputStream.wrap(input), handler, metadata, context);
        }
    }
}
```
imports: org.apache.commons.io.input.CloseShieldInputStream, org.apache.tika.exception.TikaException, org.apache.tika.io.TikaInputStream, org.apache.tika.metadata.Metadata, org.apache.tika.mime.MediaType, org.apache.tika.parser.NetworkParser.MetaHandler, org.apache.tika.parser.NetworkParser.ParsingTask, org.xml.sax.ContentHandler, org.xml.sax.SAXException, org.xml.sax.helpers.DefaultHandler

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.parser
- class name MUST be: NetworkParserparse_CloseShieldInputStreamwrapFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):

================================================================================
HARD CONSTRAINT VALIDATION FAILED
================================================================================

HARD CONSTRAINT VIOLATION: Test contains overridden method(s).
  Found 9 @Override annotation(s).
  Requirement: Test methods must not override any methods.
  Fix: Remove all @Override annotations and ensure methods are not overriding parent methods.

  Example 1:
    tputStream = new OutputStream() {
                @Override
                public void write(int b) {
                    // Do nothing
             ...

  Example 2:
    }
            };
            
            @Override
            public void connect() {
                connected = true;
            }
            
 ...

  Example 3:
    ed = true;
            }
            
            @Override
            public boolean getDoOutput() {
                return true;
            }
    ...

HARD CONSTRAINT VIOLATION: Test uses anonymous inner class(es).
  Found 3 anonymous inner class(es).
  Requirement: Do not create anonymous classes that override behavior.
  Fix: Use real object instances or mock objects without overriding methods.
  Anonymous inner classes implicitly extend/override the class behavior.

  Example 1 (class: HttpURLConnection):
    ...RLConnection mockConnection = new HttpURLConnection(mockUrl) {             private boolean connected = false;           ...

  Example 2 (class: OutputStream):
    ...l OutputStream outputStream = new OutputStream() {                 @Override                 public void write(int b) { ...

  Example 3 (class: URI):
    ...uriField.set(parser, new URI("http://localhost/test") {             @Override             public URL toURL() {          ...

================================================================================
Please regenerate the test without these violations.
Remember:
  - The test class must be standalone (no 'extends' clause)
  - Do not override any methods (no @Override)
  - Do not create anonymous inner classes (new ClassName() {...})
  - Do not use Mockito stubbing (when/doReturn/thenReturn/etc.)
  - Do not use Mockito spy() or @Spy
  - Do not use Mockito verify() or verifications
  - All methods must execute their real, unaltered implementations
================================================================================



====================================================================================================
TEST CASE 10/24 — ITERATION 1
Entry Point: org.apache.tika.config.TikaActivator.addingService(org.osgi.framework.ServiceReference)
Third Party Method: org.osgi.framework.BundleContext.getService(org.osgi.framework.ServiceReference)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.config.TikaActivator.addingService(org.osgi.framework.ServiceReference)
thirdPartyMethod: org.osgi.framework.BundleContext.getService(org.osgi.framework.ServiceReference)
path: org.apache.tika.config.TikaActivator.addingService(org.osgi.framework.ServiceReference) -> org.osgi.framework.BundleContext.getService(org.osgi.framework.ServiceReference)
methodSources:
```java
public Object addingService(ServiceReference reference) {
    int rank = 0;
    Object property = reference.getProperty(Constants.SERVICE_RANKING);
    if (property instanceof Integer) {
        rank = ((Integer) (property));
    }
    // PATH: Test should invoke the next BundleContext.getService(...) [step in execution path]
    Object service = bundleContext.getService(reference);
    ServiceLoader.addService(reference, service, rank);
    return service;
}
```
constructors:
```java
TikaActivator() {
}
```
fieldDeclarations:
```java
private ServiceTracker detectorTracker;
private ServiceTracker parserTracker;
private BundleContext bundleContext;
```
setters:
```java
public void removedService(ServiceReference reference, Object service) {
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}

// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception {
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}

public void stop(BundleContext context) throws Exception {
    parserTracker.close();
    detectorTracker.close();
}
```
imports: org.apache.tika.detect.Detector, org.apache.tika.parser.Parser, org.osgi.framework.BundleContext, org.osgi.framework.Constants, org.osgi.framework.ServiceReference, org.osgi.util.tracker.ServiceTracker

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.config
- class name MUST be: TikaActivatoraddingService_BundleContextgetServiceFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):



====================================================================================================
TEST CASE 10/24 — ITERATION 2
Entry Point: org.apache.tika.config.TikaActivator.addingService(org.osgi.framework.ServiceReference)
Third Party Method: org.osgi.framework.BundleContext.getService(org.osgi.framework.ServiceReference)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.config.TikaActivator.addingService(org.osgi.framework.ServiceReference)
thirdPartyMethod: org.osgi.framework.BundleContext.getService(org.osgi.framework.ServiceReference)
path: org.apache.tika.config.TikaActivator.addingService(org.osgi.framework.ServiceReference) -> org.osgi.framework.BundleContext.getService(org.osgi.framework.ServiceReference)
methodSources:
```java
public Object addingService(ServiceReference reference) {
    int rank = 0;
    Object property = reference.getProperty(Constants.SERVICE_RANKING);
    if (property instanceof Integer) {
        rank = ((Integer) (property));
    }
    // PATH: Test should invoke the next BundleContext.getService(...) [step in execution path]
    Object service = bundleContext.getService(reference);
    ServiceLoader.addService(reference, service, rank);
    return service;
}
```
constructors:
```java
TikaActivator() {
}
```
fieldDeclarations:
```java
private ServiceTracker detectorTracker;
private ServiceTracker parserTracker;
private BundleContext bundleContext;
```
setters:
```java
public void removedService(ServiceReference reference, Object service) {
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}

// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception {
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}

public void stop(BundleContext context) throws Exception {
    parserTracker.close();
    detectorTracker.close();
}
```
imports: org.apache.tika.detect.Detector, org.apache.tika.parser.Parser, org.osgi.framework.BundleContext, org.osgi.framework.Constants, org.osgi.framework.ServiceReference, org.osgi.util.tracker.ServiceTracker

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.config
- class name MUST be: TikaActivatoraddingService_BundleContextgetServiceFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatoraddingService_BundleContextgetServiceFikaTest.java:[4,19] package org.mockito does not exist

================================================================================



====================================================================================================
TEST CASE 10/24 — ITERATION 3
Entry Point: org.apache.tika.config.TikaActivator.addingService(org.osgi.framework.ServiceReference)
Third Party Method: org.osgi.framework.BundleContext.getService(org.osgi.framework.ServiceReference)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.config.TikaActivator.addingService(org.osgi.framework.ServiceReference)
thirdPartyMethod: org.osgi.framework.BundleContext.getService(org.osgi.framework.ServiceReference)
path: org.apache.tika.config.TikaActivator.addingService(org.osgi.framework.ServiceReference) -> org.osgi.framework.BundleContext.getService(org.osgi.framework.ServiceReference)
methodSources:
```java
public Object addingService(ServiceReference reference) {
    int rank = 0;
    Object property = reference.getProperty(Constants.SERVICE_RANKING);
    if (property instanceof Integer) {
        rank = ((Integer) (property));
    }
    // PATH: Test should invoke the next BundleContext.getService(...) [step in execution path]
    Object service = bundleContext.getService(reference);
    ServiceLoader.addService(reference, service, rank);
    return service;
}
```
constructors:
```java
TikaActivator() {
}
```
fieldDeclarations:
```java
private ServiceTracker detectorTracker;
private ServiceTracker parserTracker;
private BundleContext bundleContext;
```
setters:
```java
public void removedService(ServiceReference reference, Object service) {
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}

// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception {
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}

public void stop(BundleContext context) throws Exception {
    parserTracker.close();
    detectorTracker.close();
}
```
imports: org.apache.tika.detect.Detector, org.apache.tika.parser.Parser, org.osgi.framework.BundleContext, org.osgi.framework.Constants, org.osgi.framework.ServiceReference, org.osgi.util.tracker.ServiceTracker

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.config
- class name MUST be: TikaActivatoraddingService_BundleContextgetServiceFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatoraddingService_BundleContextgetServiceFikaTest.java:[4,19] package org.mockito does not exist

================================================================================



====================================================================================================
TEST CASE 10/24 — ITERATION 4
Entry Point: org.apache.tika.config.TikaActivator.addingService(org.osgi.framework.ServiceReference)
Third Party Method: org.osgi.framework.BundleContext.getService(org.osgi.framework.ServiceReference)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.config.TikaActivator.addingService(org.osgi.framework.ServiceReference)
thirdPartyMethod: org.osgi.framework.BundleContext.getService(org.osgi.framework.ServiceReference)
path: org.apache.tika.config.TikaActivator.addingService(org.osgi.framework.ServiceReference) -> org.osgi.framework.BundleContext.getService(org.osgi.framework.ServiceReference)
methodSources:
```java
public Object addingService(ServiceReference reference) {
    int rank = 0;
    Object property = reference.getProperty(Constants.SERVICE_RANKING);
    if (property instanceof Integer) {
        rank = ((Integer) (property));
    }
    // PATH: Test should invoke the next BundleContext.getService(...) [step in execution path]
    Object service = bundleContext.getService(reference);
    ServiceLoader.addService(reference, service, rank);
    return service;
}
```
constructors:
```java
TikaActivator() {
}
```
fieldDeclarations:
```java
private ServiceTracker detectorTracker;
private ServiceTracker parserTracker;
private BundleContext bundleContext;
```
setters:
```java
public void removedService(ServiceReference reference, Object service) {
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}

// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception {
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}

public void stop(BundleContext context) throws Exception {
    parserTracker.close();
    detectorTracker.close();
}
```
imports: org.apache.tika.detect.Detector, org.apache.tika.parser.Parser, org.osgi.framework.BundleContext, org.osgi.framework.Constants, org.osgi.framework.ServiceReference, org.osgi.util.tracker.ServiceTracker

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.config
- class name MUST be: TikaActivatoraddingService_BundleContextgetServiceFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatoraddingService_BundleContextgetServiceFikaTest.java:[4,19] package org.mockito does not exist

================================================================================



====================================================================================================
TEST CASE 10/24 — ITERATION 5
Entry Point: org.apache.tika.config.TikaActivator.addingService(org.osgi.framework.ServiceReference)
Third Party Method: org.osgi.framework.BundleContext.getService(org.osgi.framework.ServiceReference)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.config.TikaActivator.addingService(org.osgi.framework.ServiceReference)
thirdPartyMethod: org.osgi.framework.BundleContext.getService(org.osgi.framework.ServiceReference)
path: org.apache.tika.config.TikaActivator.addingService(org.osgi.framework.ServiceReference) -> org.osgi.framework.BundleContext.getService(org.osgi.framework.ServiceReference)
methodSources:
```java
public Object addingService(ServiceReference reference) {
    int rank = 0;
    Object property = reference.getProperty(Constants.SERVICE_RANKING);
    if (property instanceof Integer) {
        rank = ((Integer) (property));
    }
    // PATH: Test should invoke the next BundleContext.getService(...) [step in execution path]
    Object service = bundleContext.getService(reference);
    ServiceLoader.addService(reference, service, rank);
    return service;
}
```
constructors:
```java
TikaActivator() {
}
```
fieldDeclarations:
```java
private ServiceTracker detectorTracker;
private ServiceTracker parserTracker;
private BundleContext bundleContext;
```
setters:
```java
public void removedService(ServiceReference reference, Object service) {
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}

// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception {
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}

public void stop(BundleContext context) throws Exception {
    parserTracker.close();
    detectorTracker.close();
}
```
imports: org.apache.tika.detect.Detector, org.apache.tika.parser.Parser, org.osgi.framework.BundleContext, org.osgi.framework.Constants, org.osgi.framework.ServiceReference, org.osgi.util.tracker.ServiceTracker

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.config
- class name MUST be: TikaActivatoraddingService_BundleContextgetServiceFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatoraddingService_BundleContextgetServiceFikaTest.java:[4,19] package org.mockito does not exist

================================================================================



====================================================================================================
TEST CASE 11/24 — ITERATION 1
Entry Point: org.apache.tika.config.TikaActivator.addingService(org.osgi.framework.ServiceReference)
Third Party Method: org.osgi.framework.ServiceReference.getProperty(java.lang.String)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.config.TikaActivator.addingService(org.osgi.framework.ServiceReference)
thirdPartyMethod: org.osgi.framework.ServiceReference.getProperty(java.lang.String)
path: org.apache.tika.config.TikaActivator.addingService(org.osgi.framework.ServiceReference) -> org.osgi.framework.ServiceReference.getProperty(java.lang.String)
methodSources:
```java
public Object addingService(ServiceReference reference) {
    int rank = 0;
    // PATH: Test should invoke the next ServiceReference.getProperty(...) [step in execution path]
    Object property = reference.getProperty(Constants.SERVICE_RANKING);
    if (property instanceof Integer) {
        rank = ((Integer) (property));
    }
    Object service = bundleContext.getService(reference);
    ServiceLoader.addService(reference, service, rank);
    return service;
}
```
constructors:
```java
TikaActivator() {
}
```
fieldDeclarations:
```java
private ServiceTracker detectorTracker;
private ServiceTracker parserTracker;
private BundleContext bundleContext;
```
setters:
```java
public void removedService(ServiceReference reference, Object service) {
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}

// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception {
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}

public void stop(BundleContext context) throws Exception {
    parserTracker.close();
    detectorTracker.close();
}
```
imports: org.apache.tika.detect.Detector, org.apache.tika.parser.Parser, org.osgi.framework.BundleContext, org.osgi.framework.Constants, org.osgi.framework.ServiceReference, org.osgi.util.tracker.ServiceTracker

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.config
- class name MUST be: TikaActivatoraddingService_ServiceReferencegetPropertyFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):



====================================================================================================
TEST CASE 11/24 — ITERATION 2
Entry Point: org.apache.tika.config.TikaActivator.addingService(org.osgi.framework.ServiceReference)
Third Party Method: org.osgi.framework.ServiceReference.getProperty(java.lang.String)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.config.TikaActivator.addingService(org.osgi.framework.ServiceReference)
thirdPartyMethod: org.osgi.framework.ServiceReference.getProperty(java.lang.String)
path: org.apache.tika.config.TikaActivator.addingService(org.osgi.framework.ServiceReference) -> org.osgi.framework.ServiceReference.getProperty(java.lang.String)
methodSources:
```java
public Object addingService(ServiceReference reference) {
    int rank = 0;
    // PATH: Test should invoke the next ServiceReference.getProperty(...) [step in execution path]
    Object property = reference.getProperty(Constants.SERVICE_RANKING);
    if (property instanceof Integer) {
        rank = ((Integer) (property));
    }
    Object service = bundleContext.getService(reference);
    ServiceLoader.addService(reference, service, rank);
    return service;
}
```
constructors:
```java
TikaActivator() {
}
```
fieldDeclarations:
```java
private ServiceTracker detectorTracker;
private ServiceTracker parserTracker;
private BundleContext bundleContext;
```
setters:
```java
public void removedService(ServiceReference reference, Object service) {
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}

// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception {
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}

public void stop(BundleContext context) throws Exception {
    parserTracker.close();
    detectorTracker.close();
}
```
imports: org.apache.tika.detect.Detector, org.apache.tika.parser.Parser, org.osgi.framework.BundleContext, org.osgi.framework.Constants, org.osgi.framework.ServiceReference, org.osgi.util.tracker.ServiceTracker

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.config
- class name MUST be: TikaActivatoraddingService_ServiceReferencegetPropertyFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatoraddingService_ServiceReferencegetPropertyFikaTest.java:[11,26] package org.mockito does not exist
[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatoraddingService_ServiceReferencegetPropertyFikaTest.java:[11,1] static import only from classes and interfaces
[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatoraddingService_ServiceReferencegetPropertyFikaTest.java:[12,26] package org.mockito does not exist
[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatoraddingService_ServiceReferencegetPropertyFikaTest.java:[12,1] static import only from classes and interfaces

================================================================================



====================================================================================================
TEST CASE 11/24 — ITERATION 3
Entry Point: org.apache.tika.config.TikaActivator.addingService(org.osgi.framework.ServiceReference)
Third Party Method: org.osgi.framework.ServiceReference.getProperty(java.lang.String)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.config.TikaActivator.addingService(org.osgi.framework.ServiceReference)
thirdPartyMethod: org.osgi.framework.ServiceReference.getProperty(java.lang.String)
path: org.apache.tika.config.TikaActivator.addingService(org.osgi.framework.ServiceReference) -> org.osgi.framework.ServiceReference.getProperty(java.lang.String)
methodSources:
```java
public Object addingService(ServiceReference reference) {
    int rank = 0;
    // PATH: Test should invoke the next ServiceReference.getProperty(...) [step in execution path]
    Object property = reference.getProperty(Constants.SERVICE_RANKING);
    if (property instanceof Integer) {
        rank = ((Integer) (property));
    }
    Object service = bundleContext.getService(reference);
    ServiceLoader.addService(reference, service, rank);
    return service;
}
```
constructors:
```java
TikaActivator() {
}
```
fieldDeclarations:
```java
private ServiceTracker detectorTracker;
private ServiceTracker parserTracker;
private BundleContext bundleContext;
```
setters:
```java
public void removedService(ServiceReference reference, Object service) {
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}

// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception {
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}

public void stop(BundleContext context) throws Exception {
    parserTracker.close();
    detectorTracker.close();
}
```
imports: org.apache.tika.detect.Detector, org.apache.tika.parser.Parser, org.osgi.framework.BundleContext, org.osgi.framework.Constants, org.osgi.framework.ServiceReference, org.osgi.util.tracker.ServiceTracker

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.config
- class name MUST be: TikaActivatoraddingService_ServiceReferencegetPropertyFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):

================================================================================
HARD CONSTRAINT VALIDATION FAILED
================================================================================

HARD CONSTRAINT VIOLATION: Test uses anonymous inner class(es).
  Found 2 anonymous inner class(es).
  Requirement: Do not create anonymous classes that override behavior.
  Fix: Use real object instances or mock objects without overriding methods.
  Anonymous inner classes implicitly extend/override the class behavior.

  Example 1 (class: BundleContext):
    ...leContext mockBundleContext = new BundleContext() {             public String getProperty(String key) { return null; }  ...

  Example 2 (class: ServiceReference):
    ...eReference serviceReference = new ServiceReference() {             public Object getProperty(String key) {              ...

================================================================================
Please regenerate the test without these violations.
Remember:
  - The test class must be standalone (no 'extends' clause)
  - Do not override any methods (no @Override)
  - Do not create anonymous inner classes (new ClassName() {...})
  - Do not use Mockito stubbing (when/doReturn/thenReturn/etc.)
  - Do not use Mockito spy() or @Spy
  - Do not use Mockito verify() or verifications
  - All methods must execute their real, unaltered implementations
================================================================================



====================================================================================================
TEST CASE 11/24 — ITERATION 4
Entry Point: org.apache.tika.config.TikaActivator.addingService(org.osgi.framework.ServiceReference)
Third Party Method: org.osgi.framework.ServiceReference.getProperty(java.lang.String)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.config.TikaActivator.addingService(org.osgi.framework.ServiceReference)
thirdPartyMethod: org.osgi.framework.ServiceReference.getProperty(java.lang.String)
path: org.apache.tika.config.TikaActivator.addingService(org.osgi.framework.ServiceReference) -> org.osgi.framework.ServiceReference.getProperty(java.lang.String)
methodSources:
```java
public Object addingService(ServiceReference reference) {
    int rank = 0;
    // PATH: Test should invoke the next ServiceReference.getProperty(...) [step in execution path]
    Object property = reference.getProperty(Constants.SERVICE_RANKING);
    if (property instanceof Integer) {
        rank = ((Integer) (property));
    }
    Object service = bundleContext.getService(reference);
    ServiceLoader.addService(reference, service, rank);
    return service;
}
```
constructors:
```java
TikaActivator() {
}
```
fieldDeclarations:
```java
private ServiceTracker detectorTracker;
private ServiceTracker parserTracker;
private BundleContext bundleContext;
```
setters:
```java
public void removedService(ServiceReference reference, Object service) {
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}

// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception {
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}

public void stop(BundleContext context) throws Exception {
    parserTracker.close();
    detectorTracker.close();
}
```
imports: org.apache.tika.detect.Detector, org.apache.tika.parser.Parser, org.osgi.framework.BundleContext, org.osgi.framework.Constants, org.osgi.framework.ServiceReference, org.osgi.util.tracker.ServiceTracker

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.config
- class name MUST be: TikaActivatoraddingService_ServiceReferencegetPropertyFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatoraddingService_ServiceReferencegetPropertyFikaTest.java:[11,26] package org.mockito does not exist
[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatoraddingService_ServiceReferencegetPropertyFikaTest.java:[11,1] static import only from classes and interfaces
[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatoraddingService_ServiceReferencegetPropertyFikaTest.java:[12,26] package org.mockito does not exist
[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatoraddingService_ServiceReferencegetPropertyFikaTest.java:[12,1] static import only from classes and interfaces

================================================================================



====================================================================================================
TEST CASE 11/24 — ITERATION 5
Entry Point: org.apache.tika.config.TikaActivator.addingService(org.osgi.framework.ServiceReference)
Third Party Method: org.osgi.framework.ServiceReference.getProperty(java.lang.String)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.config.TikaActivator.addingService(org.osgi.framework.ServiceReference)
thirdPartyMethod: org.osgi.framework.ServiceReference.getProperty(java.lang.String)
path: org.apache.tika.config.TikaActivator.addingService(org.osgi.framework.ServiceReference) -> org.osgi.framework.ServiceReference.getProperty(java.lang.String)
methodSources:
```java
public Object addingService(ServiceReference reference) {
    int rank = 0;
    // PATH: Test should invoke the next ServiceReference.getProperty(...) [step in execution path]
    Object property = reference.getProperty(Constants.SERVICE_RANKING);
    if (property instanceof Integer) {
        rank = ((Integer) (property));
    }
    Object service = bundleContext.getService(reference);
    ServiceLoader.addService(reference, service, rank);
    return service;
}
```
constructors:
```java
TikaActivator() {
}
```
fieldDeclarations:
```java
private ServiceTracker detectorTracker;
private ServiceTracker parserTracker;
private BundleContext bundleContext;
```
setters:
```java
public void removedService(ServiceReference reference, Object service) {
    ServiceLoader.removeService(reference);
    bundleContext.ungetService(reference);
}

// -----------------------------------------------------< BundleActivator >
public void start(final BundleContext context) throws Exception {
    bundleContext = context;
    detectorTracker = new ServiceTracker(context, Detector.class.getName(), this);
    parserTracker = new ServiceTracker(context, Parser.class.getName(), this);
    detectorTracker.open();
    parserTracker.open();
}

public void stop(BundleContext context) throws Exception {
    parserTracker.close();
    detectorTracker.close();
}
```
imports: org.apache.tika.detect.Detector, org.apache.tika.parser.Parser, org.osgi.framework.BundleContext, org.osgi.framework.Constants, org.osgi.framework.ServiceReference, org.osgi.util.tracker.ServiceTracker

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.config
- class name MUST be: TikaActivatoraddingService_ServiceReferencegetPropertyFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatoraddingService_ServiceReferencegetPropertyFikaTest.java:[11,26] package org.mockito does not exist
[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatoraddingService_ServiceReferencegetPropertyFikaTest.java:[11,1] static import only from classes and interfaces
[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatoraddingService_ServiceReferencegetPropertyFikaTest.java:[12,26] package org.mockito does not exist
[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/config/TikaActivatoraddingService_ServiceReferencegetPropertyFikaTest.java:[12,1] static import only from classes and interfaces

================================================================================



====================================================================================================
TEST CASE 12/24 — ITERATION 1
Entry Point: org.apache.tika.io.CachingSource.skip(long)
Third Party Method: org.apache.commons.io.IOUtils.skip(java.io.InputStream, long)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.io.CachingSource.skip(long)
thirdPartyMethod: org.apache.commons.io.IOUtils.skip(java.io.InputStream, long)
path: org.apache.tika.io.CachingSource.skip(long) -> org.apache.commons.io.IOUtils.skip(java.io.InputStream, long)
methodSources:
```java
@Override
public long skip(long n) throws IOException {
    if (fileStream != null) {
        // PATH: Test should invoke the next IOUtils.skip(...) [step in execution path]
        long skipped = IOUtils.skip(fileStream, n);
        filePosition += skipped;
        return skipped;
    }
    if (cachingStream != null) {
        return cachingStream.skip(n);
    }
    long skipped = IOUtils.skip(passthroughStream, n);
    passthroughPosition += skipped;
    return skipped;
}
```
constructors:
```java
CachingSource(InputStream source, TemporaryResources tmp, long length, Metadata metadata) {
    this.tmp = tmp;
    this.length = length;
    this.metadata = metadata;
    // Start in passthrough mode
    this.passthroughStream = (source instanceof BufferedInputStream) ? ((BufferedInputStream) (source)) : new BufferedInputStream(source);
    this.passthroughPosition = 0;
}
```
fieldDeclarations:
```java
private final TemporaryResources tmp;
private final Metadata metadata;
private long length;
// Passthrough mode: just a BufferedInputStream
private BufferedInputStream passthroughStream;
private long passthroughPosition;
// Caching mode: CachingInputStream for full rewind support
private CachingInputStream cachingStream;
// After spilling to file, we switch to file-backed mode
private Path spilledPath;
private InputStream fileStream;
private long filePosition;// Track position in file mode

// Track mark position across all modes
private long markPosition = -1;
```
setters:
```java
@Override
public void close() throws IOException {
    if (fileStream != null) {
        fileStream.close();
    }
    if (cachingStream != null) {
        cachingStream.close();
    }
    if (passthroughStream != null) {
        passthroughStream.close();
    }
}

@Override
public void enableRewind() {
    // Already in caching or file mode - no-op
    if ((cachingStream != null) || (fileStream != null)) {
        return;
    }
    if (passthroughPosition != 0) {
        throw new IllegalStateException(("Cannot enable rewind: position is " + passthroughPosition) + ", must be 0. Call enableRewind() before reading.");
    }
    // Switch to caching mode
    StreamCache cache = new StreamCache(tmp);
    cachingStream = new CachingInputStream(passthroughStream, cache);
    passthroughStream = null;
}

@Override
public synchronized void mark(int readlimit) {
    if (fileStream != null) {
        // File mode - track position for seekTo-based reset
        markPosition = filePosition;
        return;
    }
    if (cachingStream != null) {
        // Caching mode - track position for seekTo-based reset
        markPosition = cachingStream.getPosition();
        return;
    }
    // Passthrough mode - delegate to BufferedInputStream
    passthroughStream.mark(readlimit);
    markPosition = passthroughPosition;
}

@Override
public synchronized void reset() throws IOException {
    if (markPosition < 0) {
        throw new IOException("Mark not set");
    }
    if (fileStream != null) {
        // File mode - use seekTo
        seekTo(markPosition);
        return;
    }
    if (cachingStream != null) {
        // Caching mode - use seekTo
        cachingStream.seekTo(markPosition);
        return;
    }
    // Passthrough mode - delegate to BufferedInputStream
    passthroughStream.reset();
    passthroughPosition = markPosition;
}

@Override
public void seekTo(long position) throws IOException {
    if (fileStream != null) {
        // After spilling, we need to reopen the file and skip
        fileStream.close();
        fileStream = new BufferedInputStream(Files.newInputStream(spilledPath));
        if (position > 0) {
            IOUtils.skipFully(fileStream, position);
        }
        filePosition = position;
        return;
    }
    if (cachingStream != null) {
        cachingStream.seekTo(position);
        return;
    }
    // Passthrough mode - can only "seek" to current position
    if (position != passthroughPosition) {
        throw new IOException(((("Cannot seek in passthrough mode. Call enableRewind() first. " + "Current position: ") + passthroughPosition) + ", requested: ") + position);
    }
}
```
imports: org.apache.commons.io.IOUtils, org.apache.tika.metadata.Metadata, org.apache.tika.utils.StringUtils

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.io
- class name MUST be: CachingSourceskip_IOUtilsskipFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):



====================================================================================================
TEST CASE 12/24 — ITERATION 2
Entry Point: org.apache.tika.io.CachingSource.skip(long)
Third Party Method: org.apache.commons.io.IOUtils.skip(java.io.InputStream, long)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.io.CachingSource.skip(long)
thirdPartyMethod: org.apache.commons.io.IOUtils.skip(java.io.InputStream, long)
path: org.apache.tika.io.CachingSource.skip(long) -> org.apache.commons.io.IOUtils.skip(java.io.InputStream, long)
methodSources:
```java
@Override
public long skip(long n) throws IOException {
    if (fileStream != null) {
        // PATH: Test should invoke the next IOUtils.skip(...) [step in execution path]
        long skipped = IOUtils.skip(fileStream, n);
        filePosition += skipped;
        return skipped;
    }
    if (cachingStream != null) {
        return cachingStream.skip(n);
    }
    long skipped = IOUtils.skip(passthroughStream, n);
    passthroughPosition += skipped;
    return skipped;
}
```
constructors:
```java
CachingSource(InputStream source, TemporaryResources tmp, long length, Metadata metadata) {
    this.tmp = tmp;
    this.length = length;
    this.metadata = metadata;
    // Start in passthrough mode
    this.passthroughStream = (source instanceof BufferedInputStream) ? ((BufferedInputStream) (source)) : new BufferedInputStream(source);
    this.passthroughPosition = 0;
}
```
fieldDeclarations:
```java
private final TemporaryResources tmp;
private final Metadata metadata;
private long length;
// Passthrough mode: just a BufferedInputStream
private BufferedInputStream passthroughStream;
private long passthroughPosition;
// Caching mode: CachingInputStream for full rewind support
private CachingInputStream cachingStream;
// After spilling to file, we switch to file-backed mode
private Path spilledPath;
private InputStream fileStream;
private long filePosition;// Track position in file mode

// Track mark position across all modes
private long markPosition = -1;
```
setters:
```java
@Override
public void close() throws IOException {
    if (fileStream != null) {
        fileStream.close();
    }
    if (cachingStream != null) {
        cachingStream.close();
    }
    if (passthroughStream != null) {
        passthroughStream.close();
    }
}

@Override
public void enableRewind() {
    // Already in caching or file mode - no-op
    if ((cachingStream != null) || (fileStream != null)) {
        return;
    }
    if (passthroughPosition != 0) {
        throw new IllegalStateException(("Cannot enable rewind: position is " + passthroughPosition) + ", must be 0. Call enableRewind() before reading.");
    }
    // Switch to caching mode
    StreamCache cache = new StreamCache(tmp);
    cachingStream = new CachingInputStream(passthroughStream, cache);
    passthroughStream = null;
}

@Override
public synchronized void mark(int readlimit) {
    if (fileStream != null) {
        // File mode - track position for seekTo-based reset
        markPosition = filePosition;
        return;
    }
    if (cachingStream != null) {
        // Caching mode - track position for seekTo-based reset
        markPosition = cachingStream.getPosition();
        return;
    }
    // Passthrough mode - delegate to BufferedInputStream
    passthroughStream.mark(readlimit);
    markPosition = passthroughPosition;
}

@Override
public synchronized void reset() throws IOException {
    if (markPosition < 0) {
        throw new IOException("Mark not set");
    }
    if (fileStream != null) {
        // File mode - use seekTo
        seekTo(markPosition);
        return;
    }
    if (cachingStream != null) {
        // Caching mode - use seekTo
        cachingStream.seekTo(markPosition);
        return;
    }
    // Passthrough mode - delegate to BufferedInputStream
    passthroughStream.reset();
    passthroughPosition = markPosition;
}

@Override
public void seekTo(long position) throws IOException {
    if (fileStream != null) {
        // After spilling, we need to reopen the file and skip
        fileStream.close();
        fileStream = new BufferedInputStream(Files.newInputStream(spilledPath));
        if (position > 0) {
            IOUtils.skipFully(fileStream, position);
        }
        filePosition = position;
        return;
    }
    if (cachingStream != null) {
        cachingStream.seekTo(position);
        return;
    }
    // Passthrough mode - can only "seek" to current position
    if (position != passthroughPosition) {
        throw new IOException(((("Cannot seek in passthrough mode. Call enableRewind() first. " + "Current position: ") + passthroughPosition) + ", requested: ") + position);
    }
}
```
imports: org.apache.commons.io.IOUtils, org.apache.tika.metadata.Metadata, org.apache.tika.utils.StringUtils

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.io
- class name MUST be: CachingSourceskip_IOUtilsskipFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/io/CachingSourceskip_IOUtilsskipFikaTest.java:[14,9] cannot find symbol
  symbol:   class InputStream
  location: class org.apache.tika.io.CachingSourceskip_IOUtilsskipFikaTest

================================================================================



====================================================================================================
TEST CASE 13/24 — ITERATION 1
Entry Point: org.apache.tika.io.FileSource.seekTo(long)
Third Party Method: org.apache.commons.io.IOUtils.skipFully(java.io.InputStream, long)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.io.FileSource.seekTo(long)
thirdPartyMethod: org.apache.commons.io.IOUtils.skipFully(java.io.InputStream, long)
path: org.apache.tika.io.FileSource.seekTo(long) -> org.apache.commons.io.IOUtils.skipFully(java.io.InputStream, long)
methodSources:
```java
@Override
public void seekTo(long newPosition) throws IOException {
    if (newPosition < 0) {
        throw new IOException("Cannot seek to negative position: " + newPosition);
    }
    if (newPosition > length) {
        throw new IOException((("Cannot seek past end of file. Position: " + newPosition) + ", length: ") + length);
    }
    // Close current stream and reopen at the beginning
    currentStream.close();
    currentStream = new BufferedInputStream(Files.newInputStream(path));
    // Skip to the new position
    if (newPosition > 0) // PATH: Test should invoke the next IOUtils.skipFully(...) [step in execution path]
    {
        IOUtils.skipFully(currentStream, newPosition);
    }
    this.position = newPosition;
}
```
constructors:
```java
FileSource(Path path) throws IOException {
    this.path = path;
    this.length = Files.size(path);
    this.currentStream = new BufferedInputStream(Files.newInputStream(path));
    this.position = 0;
}
```
fieldDeclarations:
```java
private final Path path;
private final long length;
private InputStream currentStream;
private long position;
// Mark/reset support using seekTo
private long markPosition = -1;
```
setters:
```java
@Override
public void close() throws IOException {
    if (currentStream != null) {
        currentStream.close();
    }
}

@Override
public synchronized void mark(int readlimit) {
    markPosition = position;
}

@Override
public void seekTo(long newPosition) throws IOException {
    if (newPosition < 0) {
        throw new IOException("Cannot seek to negative position: " + newPosition);
    }
    if (newPosition > length) {
        throw new IOException((("Cannot seek past end of file. Position: " + newPosition) + ", length: ") + length);
    }
    // Close current stream and reopen at the beginning
    currentStream.close();
    currentStream = new BufferedInputStream(Files.newInputStream(path));
    // Skip to the new position
    if (newPosition > 0) {
        IOUtils.skipFully(currentStream, newPosition);
    }
    this.position = newPosition;
}
```
imports: org.apache.commons.io.IOUtils

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.io
- class name MUST be: FileSourceseekTo_IOUtilsskipFullyFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):



====================================================================================================
TEST CASE 14/24 — ITERATION 1
Entry Point: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
Third Party Method: org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.Builder.get()
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
thirdPartyMethod: org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.Builder.get()
path: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext) -> org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.Builder.get()
methodSources:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    // PATH: Test should invoke the next UnsynchronizedByteArrayOutputStream$Builder.get(...) [step in execution path]
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) {
            sendStdOutToOutputStream(process, outputStream);
        } else {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}
```
constructors:
```java
ExternalEmbedder() {
}
```
fieldDeclarations:
```java
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_TOKEN = "${METADATA}";
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN = "${METADATA_SERIALIZED}";
private static final long serialVersionUID = -2828829275642475697L;
private final TemporaryResources tmp = new TemporaryResources();
/**
 * Media types supported by the external program.
 */
private Set<MediaType> supportedEmbedTypes = Collections.emptySet();
/**
 * Mapping of Tika metadata to command line parameters.
 */
private Map<Property, String[]> metadataCommandArguments = null;
/**
 * The external command to invoke.
 *
 * @see Runtime#exec(String[])
 */
private String[] command = new String[]{ "sed", "-e", "$a\\
" + METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, ExternalParser.INPUT_FILE_TOKEN };
private String commandAssignmentOperator = "=";
private String commandAssignmentDelimeter = ", ";
private String commandAppendOperator = "=";
private boolean quoteAssignmentValues = false;
```
setters:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) {
            sendStdOutToOutputStream(process, outputStream);
        } else {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}

/**
 * Sets the command to be run. This can include either of
 * {@link ExternalParser#INPUT_FILE_TOKEN} or
 * {@link ExternalParser#OUTPUT_FILE_TOKEN} if the command
 * needs filenames.
 *
 * @see Runtime#exec(String[])
 */
public void setCommand(String... command) {
    this.command = command;
}

/**
 * Sets the operator to append rather than replace a value for the command
 * line tool, i.e. "+=".
 *
 * @param commandAppendOperator
 */
public void setCommandAppendOperator(String commandAppendOperator) {
    this.commandAppendOperator = commandAppendOperator;
}

/**
 * Sets the delimiter for multiple assignments for the command line tool,
 * i.e. ", ".
 *
 * @param commandAssignmentDelimeter
 */
public void setCommandAssignmentDelimeter(String commandAssignmentDelimeter) {
    this.commandAssignmentDelimeter = commandAssignmentDelimeter;
}

/**
 * Sets the assignment operator for the command line tool, i.e. "=".
 *
 * @param commandAssignmentOperator
 */
public void setCommandAssignmentOperator(String commandAssignmentOperator) {
    this.commandAssignmentOperator = commandAssignmentOperator;
}

/**
 * Sets the map of Metadata keys to command line parameters. Set this to
 * null to disable Metadata embedding.
 *
 * @param arguments
 */
public void setMetadataCommandArguments(Map<Property, String[]> arguments) {
    this.metadataCommandArguments = arguments;
}

/**
 * Sets whether or not to quote assignment values, i.e. tag='value'.
 *
 * @param quoteAssignmentValues
 */
public void setQuoteAssignmentValues(boolean quoteAssignmentValues) {
    this.quoteAssignmentValues = quoteAssignmentValues;
}

public void setSupportedEmbedTypes(Set<MediaType> supportedEmbedTypes) {
    this.supportedEmbedTypes = Collections.unmodifiableSet(new HashSet<>(supportedEmbedTypes));
}
```
imports: org.apache.commons.io.IOUtils, org.apache.commons.io.output.AbstractByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.Builder, org.apache.tika.exception.TikaException, org.apache.tika.io.TemporaryResources, org.apache.tika.io.TikaInputStream, org.apache.tika.metadata.Metadata, org.apache.tika.metadata.Property, org.apache.tika.mime.MediaType, org.apache.tika.parser.ParseContext, org.apache.tika.parser.external.ExternalParser

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.embedder
- class name MUST be: ExternalEmbedderembed_BuildergetFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):



====================================================================================================
TEST CASE 15/24 — ITERATION 1
Entry Point: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
Third Party Method: org.apache.commons.io.IOUtils.closeQuietly(java.io.InputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
thirdPartyMethod: org.apache.commons.io.IOUtils.closeQuietly(java.io.InputStream)
path: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext) -> org.apache.commons.io.IOUtils.closeQuietly(java.io.InputStream)
methodSources:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) {
            sendStdOutToOutputStream(process, outputStream);
        } else {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) // PATH: Test should invoke the next IOUtils.closeQuietly(...) [step in execution path]
        {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}
```
constructors:
```java
ExternalEmbedder() {
}
```
fieldDeclarations:
```java
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_TOKEN = "${METADATA}";
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN = "${METADATA_SERIALIZED}";
private static final long serialVersionUID = -2828829275642475697L;
private final TemporaryResources tmp = new TemporaryResources();
/**
 * Media types supported by the external program.
 */
private Set<MediaType> supportedEmbedTypes = Collections.emptySet();
/**
 * Mapping of Tika metadata to command line parameters.
 */
private Map<Property, String[]> metadataCommandArguments = null;
/**
 * The external command to invoke.
 *
 * @see Runtime#exec(String[])
 */
private String[] command = new String[]{ "sed", "-e", "$a\\
" + METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, ExternalParser.INPUT_FILE_TOKEN };
private String commandAssignmentOperator = "=";
private String commandAssignmentDelimeter = ", ";
private String commandAppendOperator = "=";
private boolean quoteAssignmentValues = false;
```
setters:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) {
            sendStdOutToOutputStream(process, outputStream);
        } else {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}

/**
 * Sets the command to be run. This can include either of
 * {@link ExternalParser#INPUT_FILE_TOKEN} or
 * {@link ExternalParser#OUTPUT_FILE_TOKEN} if the command
 * needs filenames.
 *
 * @see Runtime#exec(String[])
 */
public void setCommand(String... command) {
    this.command = command;
}

/**
 * Sets the operator to append rather than replace a value for the command
 * line tool, i.e. "+=".
 *
 * @param commandAppendOperator
 */
public void setCommandAppendOperator(String commandAppendOperator) {
    this.commandAppendOperator = commandAppendOperator;
}

/**
 * Sets the delimiter for multiple assignments for the command line tool,
 * i.e. ", ".
 *
 * @param commandAssignmentDelimeter
 */
public void setCommandAssignmentDelimeter(String commandAssignmentDelimeter) {
    this.commandAssignmentDelimeter = commandAssignmentDelimeter;
}

/**
 * Sets the assignment operator for the command line tool, i.e. "=".
 *
 * @param commandAssignmentOperator
 */
public void setCommandAssignmentOperator(String commandAssignmentOperator) {
    this.commandAssignmentOperator = commandAssignmentOperator;
}

/**
 * Sets the map of Metadata keys to command line parameters. Set this to
 * null to disable Metadata embedding.
 *
 * @param arguments
 */
public void setMetadataCommandArguments(Map<Property, String[]> arguments) {
    this.metadataCommandArguments = arguments;
}

/**
 * Sets whether or not to quote assignment values, i.e. tag='value'.
 *
 * @param quoteAssignmentValues
 */
public void setQuoteAssignmentValues(boolean quoteAssignmentValues) {
    this.quoteAssignmentValues = quoteAssignmentValues;
}

public void setSupportedEmbedTypes(Set<MediaType> supportedEmbedTypes) {
    this.supportedEmbedTypes = Collections.unmodifiableSet(new HashSet<>(supportedEmbedTypes));
}
```
imports: org.apache.commons.io.IOUtils, org.apache.commons.io.output.AbstractByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.Builder, org.apache.tika.exception.TikaException, org.apache.tika.io.TemporaryResources, org.apache.tika.io.TikaInputStream, org.apache.tika.metadata.Metadata, org.apache.tika.metadata.Property, org.apache.tika.mime.MediaType, org.apache.tika.parser.ParseContext, org.apache.tika.parser.external.ExternalParser

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.embedder
- class name MUST be: ExternalEmbedderembed_IOUtilscloseQuietlyFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):



====================================================================================================
TEST CASE 15/24 — ITERATION 2
Entry Point: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
Third Party Method: org.apache.commons.io.IOUtils.closeQuietly(java.io.InputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
thirdPartyMethod: org.apache.commons.io.IOUtils.closeQuietly(java.io.InputStream)
path: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext) -> org.apache.commons.io.IOUtils.closeQuietly(java.io.InputStream)
methodSources:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) {
            sendStdOutToOutputStream(process, outputStream);
        } else {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) // PATH: Test should invoke the next IOUtils.closeQuietly(...) [step in execution path]
        {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}
```
constructors:
```java
ExternalEmbedder() {
}
```
fieldDeclarations:
```java
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_TOKEN = "${METADATA}";
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN = "${METADATA_SERIALIZED}";
private static final long serialVersionUID = -2828829275642475697L;
private final TemporaryResources tmp = new TemporaryResources();
/**
 * Media types supported by the external program.
 */
private Set<MediaType> supportedEmbedTypes = Collections.emptySet();
/**
 * Mapping of Tika metadata to command line parameters.
 */
private Map<Property, String[]> metadataCommandArguments = null;
/**
 * The external command to invoke.
 *
 * @see Runtime#exec(String[])
 */
private String[] command = new String[]{ "sed", "-e", "$a\\
" + METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, ExternalParser.INPUT_FILE_TOKEN };
private String commandAssignmentOperator = "=";
private String commandAssignmentDelimeter = ", ";
private String commandAppendOperator = "=";
private boolean quoteAssignmentValues = false;
```
setters:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) {
            sendStdOutToOutputStream(process, outputStream);
        } else {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}

/**
 * Sets the command to be run. This can include either of
 * {@link ExternalParser#INPUT_FILE_TOKEN} or
 * {@link ExternalParser#OUTPUT_FILE_TOKEN} if the command
 * needs filenames.
 *
 * @see Runtime#exec(String[])
 */
public void setCommand(String... command) {
    this.command = command;
}

/**
 * Sets the operator to append rather than replace a value for the command
 * line tool, i.e. "+=".
 *
 * @param commandAppendOperator
 */
public void setCommandAppendOperator(String commandAppendOperator) {
    this.commandAppendOperator = commandAppendOperator;
}

/**
 * Sets the delimiter for multiple assignments for the command line tool,
 * i.e. ", ".
 *
 * @param commandAssignmentDelimeter
 */
public void setCommandAssignmentDelimeter(String commandAssignmentDelimeter) {
    this.commandAssignmentDelimeter = commandAssignmentDelimeter;
}

/**
 * Sets the assignment operator for the command line tool, i.e. "=".
 *
 * @param commandAssignmentOperator
 */
public void setCommandAssignmentOperator(String commandAssignmentOperator) {
    this.commandAssignmentOperator = commandAssignmentOperator;
}

/**
 * Sets the map of Metadata keys to command line parameters. Set this to
 * null to disable Metadata embedding.
 *
 * @param arguments
 */
public void setMetadataCommandArguments(Map<Property, String[]> arguments) {
    this.metadataCommandArguments = arguments;
}

/**
 * Sets whether or not to quote assignment values, i.e. tag='value'.
 *
 * @param quoteAssignmentValues
 */
public void setQuoteAssignmentValues(boolean quoteAssignmentValues) {
    this.quoteAssignmentValues = quoteAssignmentValues;
}

public void setSupportedEmbedTypes(Set<MediaType> supportedEmbedTypes) {
    this.supportedEmbedTypes = Collections.unmodifiableSet(new HashSet<>(supportedEmbedTypes));
}
```
imports: org.apache.commons.io.IOUtils, org.apache.commons.io.output.AbstractByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.Builder, org.apache.tika.exception.TikaException, org.apache.tika.io.TemporaryResources, org.apache.tika.io.TikaInputStream, org.apache.tika.metadata.Metadata, org.apache.tika.metadata.Property, org.apache.tika.mime.MediaType, org.apache.tika.parser.ParseContext, org.apache.tika.parser.external.ExternalParser

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.embedder
- class name MUST be: ExternalEmbedderembed_IOUtilscloseQuietlyFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/embedder/ExternalEmbedderembed_IOUtilscloseQuietlyFikaTest.java:[36,34] cannot find symbol
  symbol:   method externalClosedChoices(java.lang.String)
  location: class org.apache.tika.metadata.Property

================================================================================



====================================================================================================
TEST CASE 16/24 — ITERATION 1
Entry Point: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
Third Party Method: org.apache.commons.io.IOUtils.closeQuietly(java.io.OutputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
thirdPartyMethod: org.apache.commons.io.IOUtils.closeQuietly(java.io.OutputStream)
path: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext) -> org.apache.commons.io.IOUtils.closeQuietly(java.io.OutputStream)
methodSources:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) {
            sendStdOutToOutputStream(process, outputStream);
        } else {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) // PATH: Test should invoke the next IOUtils.closeQuietly(...) [step in execution path]
        {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}
```
constructors:
```java
ExternalEmbedder() {
}
```
fieldDeclarations:
```java
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_TOKEN = "${METADATA}";
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN = "${METADATA_SERIALIZED}";
private static final long serialVersionUID = -2828829275642475697L;
private final TemporaryResources tmp = new TemporaryResources();
/**
 * Media types supported by the external program.
 */
private Set<MediaType> supportedEmbedTypes = Collections.emptySet();
/**
 * Mapping of Tika metadata to command line parameters.
 */
private Map<Property, String[]> metadataCommandArguments = null;
/**
 * The external command to invoke.
 *
 * @see Runtime#exec(String[])
 */
private String[] command = new String[]{ "sed", "-e", "$a\\
" + METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, ExternalParser.INPUT_FILE_TOKEN };
private String commandAssignmentOperator = "=";
private String commandAssignmentDelimeter = ", ";
private String commandAppendOperator = "=";
private boolean quoteAssignmentValues = false;
```
setters:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) {
            sendStdOutToOutputStream(process, outputStream);
        } else {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}

/**
 * Sets the command to be run. This can include either of
 * {@link ExternalParser#INPUT_FILE_TOKEN} or
 * {@link ExternalParser#OUTPUT_FILE_TOKEN} if the command
 * needs filenames.
 *
 * @see Runtime#exec(String[])
 */
public void setCommand(String... command) {
    this.command = command;
}

/**
 * Sets the operator to append rather than replace a value for the command
 * line tool, i.e. "+=".
 *
 * @param commandAppendOperator
 */
public void setCommandAppendOperator(String commandAppendOperator) {
    this.commandAppendOperator = commandAppendOperator;
}

/**
 * Sets the delimiter for multiple assignments for the command line tool,
 * i.e. ", ".
 *
 * @param commandAssignmentDelimeter
 */
public void setCommandAssignmentDelimeter(String commandAssignmentDelimeter) {
    this.commandAssignmentDelimeter = commandAssignmentDelimeter;
}

/**
 * Sets the assignment operator for the command line tool, i.e. "=".
 *
 * @param commandAssignmentOperator
 */
public void setCommandAssignmentOperator(String commandAssignmentOperator) {
    this.commandAssignmentOperator = commandAssignmentOperator;
}

/**
 * Sets the map of Metadata keys to command line parameters. Set this to
 * null to disable Metadata embedding.
 *
 * @param arguments
 */
public void setMetadataCommandArguments(Map<Property, String[]> arguments) {
    this.metadataCommandArguments = arguments;
}

/**
 * Sets whether or not to quote assignment values, i.e. tag='value'.
 *
 * @param quoteAssignmentValues
 */
public void setQuoteAssignmentValues(boolean quoteAssignmentValues) {
    this.quoteAssignmentValues = quoteAssignmentValues;
}

public void setSupportedEmbedTypes(Set<MediaType> supportedEmbedTypes) {
    this.supportedEmbedTypes = Collections.unmodifiableSet(new HashSet<>(supportedEmbedTypes));
}
```
imports: org.apache.commons.io.IOUtils, org.apache.commons.io.output.AbstractByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.Builder, org.apache.tika.exception.TikaException, org.apache.tika.io.TemporaryResources, org.apache.tika.io.TikaInputStream, org.apache.tika.metadata.Metadata, org.apache.tika.metadata.Property, org.apache.tika.mime.MediaType, org.apache.tika.parser.ParseContext, org.apache.tika.parser.external.ExternalParser

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.embedder
- class name MUST be: ExternalEmbedderembed_IOUtilscloseQuietlyFikaTest2
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):



====================================================================================================
TEST CASE 16/24 — ITERATION 2
Entry Point: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
Third Party Method: org.apache.commons.io.IOUtils.closeQuietly(java.io.OutputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
thirdPartyMethod: org.apache.commons.io.IOUtils.closeQuietly(java.io.OutputStream)
path: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext) -> org.apache.commons.io.IOUtils.closeQuietly(java.io.OutputStream)
methodSources:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) {
            sendStdOutToOutputStream(process, outputStream);
        } else {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) // PATH: Test should invoke the next IOUtils.closeQuietly(...) [step in execution path]
        {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}
```
constructors:
```java
ExternalEmbedder() {
}
```
fieldDeclarations:
```java
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_TOKEN = "${METADATA}";
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN = "${METADATA_SERIALIZED}";
private static final long serialVersionUID = -2828829275642475697L;
private final TemporaryResources tmp = new TemporaryResources();
/**
 * Media types supported by the external program.
 */
private Set<MediaType> supportedEmbedTypes = Collections.emptySet();
/**
 * Mapping of Tika metadata to command line parameters.
 */
private Map<Property, String[]> metadataCommandArguments = null;
/**
 * The external command to invoke.
 *
 * @see Runtime#exec(String[])
 */
private String[] command = new String[]{ "sed", "-e", "$a\\
" + METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, ExternalParser.INPUT_FILE_TOKEN };
private String commandAssignmentOperator = "=";
private String commandAssignmentDelimeter = ", ";
private String commandAppendOperator = "=";
private boolean quoteAssignmentValues = false;
```
setters:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) {
            sendStdOutToOutputStream(process, outputStream);
        } else {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}

/**
 * Sets the command to be run. This can include either of
 * {@link ExternalParser#INPUT_FILE_TOKEN} or
 * {@link ExternalParser#OUTPUT_FILE_TOKEN} if the command
 * needs filenames.
 *
 * @see Runtime#exec(String[])
 */
public void setCommand(String... command) {
    this.command = command;
}

/**
 * Sets the operator to append rather than replace a value for the command
 * line tool, i.e. "+=".
 *
 * @param commandAppendOperator
 */
public void setCommandAppendOperator(String commandAppendOperator) {
    this.commandAppendOperator = commandAppendOperator;
}

/**
 * Sets the delimiter for multiple assignments for the command line tool,
 * i.e. ", ".
 *
 * @param commandAssignmentDelimeter
 */
public void setCommandAssignmentDelimeter(String commandAssignmentDelimeter) {
    this.commandAssignmentDelimeter = commandAssignmentDelimeter;
}

/**
 * Sets the assignment operator for the command line tool, i.e. "=".
 *
 * @param commandAssignmentOperator
 */
public void setCommandAssignmentOperator(String commandAssignmentOperator) {
    this.commandAssignmentOperator = commandAssignmentOperator;
}

/**
 * Sets the map of Metadata keys to command line parameters. Set this to
 * null to disable Metadata embedding.
 *
 * @param arguments
 */
public void setMetadataCommandArguments(Map<Property, String[]> arguments) {
    this.metadataCommandArguments = arguments;
}

/**
 * Sets whether or not to quote assignment values, i.e. tag='value'.
 *
 * @param quoteAssignmentValues
 */
public void setQuoteAssignmentValues(boolean quoteAssignmentValues) {
    this.quoteAssignmentValues = quoteAssignmentValues;
}

public void setSupportedEmbedTypes(Set<MediaType> supportedEmbedTypes) {
    this.supportedEmbedTypes = Collections.unmodifiableSet(new HashSet<>(supportedEmbedTypes));
}
```
imports: org.apache.commons.io.IOUtils, org.apache.commons.io.output.AbstractByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.Builder, org.apache.tika.exception.TikaException, org.apache.tika.io.TemporaryResources, org.apache.tika.io.TikaInputStream, org.apache.tika.metadata.Metadata, org.apache.tika.metadata.Property, org.apache.tika.mime.MediaType, org.apache.tika.parser.ParseContext, org.apache.tika.parser.external.ExternalParser

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.embedder
- class name MUST be: ExternalEmbedderembed_IOUtilscloseQuietlyFikaTest2
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/embedder/ExternalEmbedderembed_IOUtilscloseQuietlyFikaTest2.java:[29,34] cannot find symbol
  symbol:   method externalClosedChoices(java.lang.String)
  location: class org.apache.tika.metadata.Property

================================================================================



====================================================================================================
TEST CASE 16/24 — ITERATION 3
Entry Point: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
Third Party Method: org.apache.commons.io.IOUtils.closeQuietly(java.io.OutputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
thirdPartyMethod: org.apache.commons.io.IOUtils.closeQuietly(java.io.OutputStream)
path: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext) -> org.apache.commons.io.IOUtils.closeQuietly(java.io.OutputStream)
methodSources:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) {
            sendStdOutToOutputStream(process, outputStream);
        } else {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) // PATH: Test should invoke the next IOUtils.closeQuietly(...) [step in execution path]
        {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}
```
constructors:
```java
ExternalEmbedder() {
}
```
fieldDeclarations:
```java
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_TOKEN = "${METADATA}";
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN = "${METADATA_SERIALIZED}";
private static final long serialVersionUID = -2828829275642475697L;
private final TemporaryResources tmp = new TemporaryResources();
/**
 * Media types supported by the external program.
 */
private Set<MediaType> supportedEmbedTypes = Collections.emptySet();
/**
 * Mapping of Tika metadata to command line parameters.
 */
private Map<Property, String[]> metadataCommandArguments = null;
/**
 * The external command to invoke.
 *
 * @see Runtime#exec(String[])
 */
private String[] command = new String[]{ "sed", "-e", "$a\\
" + METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, ExternalParser.INPUT_FILE_TOKEN };
private String commandAssignmentOperator = "=";
private String commandAssignmentDelimeter = ", ";
private String commandAppendOperator = "=";
private boolean quoteAssignmentValues = false;
```
setters:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) {
            sendStdOutToOutputStream(process, outputStream);
        } else {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}

/**
 * Sets the command to be run. This can include either of
 * {@link ExternalParser#INPUT_FILE_TOKEN} or
 * {@link ExternalParser#OUTPUT_FILE_TOKEN} if the command
 * needs filenames.
 *
 * @see Runtime#exec(String[])
 */
public void setCommand(String... command) {
    this.command = command;
}

/**
 * Sets the operator to append rather than replace a value for the command
 * line tool, i.e. "+=".
 *
 * @param commandAppendOperator
 */
public void setCommandAppendOperator(String commandAppendOperator) {
    this.commandAppendOperator = commandAppendOperator;
}

/**
 * Sets the delimiter for multiple assignments for the command line tool,
 * i.e. ", ".
 *
 * @param commandAssignmentDelimeter
 */
public void setCommandAssignmentDelimeter(String commandAssignmentDelimeter) {
    this.commandAssignmentDelimeter = commandAssignmentDelimeter;
}

/**
 * Sets the assignment operator for the command line tool, i.e. "=".
 *
 * @param commandAssignmentOperator
 */
public void setCommandAssignmentOperator(String commandAssignmentOperator) {
    this.commandAssignmentOperator = commandAssignmentOperator;
}

/**
 * Sets the map of Metadata keys to command line parameters. Set this to
 * null to disable Metadata embedding.
 *
 * @param arguments
 */
public void setMetadataCommandArguments(Map<Property, String[]> arguments) {
    this.metadataCommandArguments = arguments;
}

/**
 * Sets whether or not to quote assignment values, i.e. tag='value'.
 *
 * @param quoteAssignmentValues
 */
public void setQuoteAssignmentValues(boolean quoteAssignmentValues) {
    this.quoteAssignmentValues = quoteAssignmentValues;
}

public void setSupportedEmbedTypes(Set<MediaType> supportedEmbedTypes) {
    this.supportedEmbedTypes = Collections.unmodifiableSet(new HashSet<>(supportedEmbedTypes));
}
```
imports: org.apache.commons.io.IOUtils, org.apache.commons.io.output.AbstractByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.Builder, org.apache.tika.exception.TikaException, org.apache.tika.io.TemporaryResources, org.apache.tika.io.TikaInputStream, org.apache.tika.metadata.Metadata, org.apache.tika.metadata.Property, org.apache.tika.mime.MediaType, org.apache.tika.parser.ParseContext, org.apache.tika.parser.external.ExternalParser

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.embedder
- class name MUST be: ExternalEmbedderembed_IOUtilscloseQuietlyFikaTest2
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/embedder/ExternalEmbedderembed_IOUtilscloseQuietlyFikaTest2.java:[27,34] cannot find symbol
  symbol:   method externalClosedChoices(java.lang.String)
  location: class org.apache.tika.metadata.Property

================================================================================



====================================================================================================
TEST CASE 17/24 — ITERATION 1
Entry Point: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
Third Party Method: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
thirdPartyMethod: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
path: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext) -> org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
methodSources:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) {
            sendStdOutToOutputStream(process, outputStream);
        } else // PATH: Test should invoke the next IOUtils.copy(...) [step in execution path]
        {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}
```
constructors:
```java
ExternalEmbedder() {
}
```
fieldDeclarations:
```java
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_TOKEN = "${METADATA}";
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN = "${METADATA_SERIALIZED}";
private static final long serialVersionUID = -2828829275642475697L;
private final TemporaryResources tmp = new TemporaryResources();
/**
 * Media types supported by the external program.
 */
private Set<MediaType> supportedEmbedTypes = Collections.emptySet();
/**
 * Mapping of Tika metadata to command line parameters.
 */
private Map<Property, String[]> metadataCommandArguments = null;
/**
 * The external command to invoke.
 *
 * @see Runtime#exec(String[])
 */
private String[] command = new String[]{ "sed", "-e", "$a\\
" + METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, ExternalParser.INPUT_FILE_TOKEN };
private String commandAssignmentOperator = "=";
private String commandAssignmentDelimeter = ", ";
private String commandAppendOperator = "=";
private boolean quoteAssignmentValues = false;
```
setters:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) {
            sendStdOutToOutputStream(process, outputStream);
        } else {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}

/**
 * Sets the command to be run. This can include either of
 * {@link ExternalParser#INPUT_FILE_TOKEN} or
 * {@link ExternalParser#OUTPUT_FILE_TOKEN} if the command
 * needs filenames.
 *
 * @see Runtime#exec(String[])
 */
public void setCommand(String... command) {
    this.command = command;
}

/**
 * Sets the operator to append rather than replace a value for the command
 * line tool, i.e. "+=".
 *
 * @param commandAppendOperator
 */
public void setCommandAppendOperator(String commandAppendOperator) {
    this.commandAppendOperator = commandAppendOperator;
}

/**
 * Sets the delimiter for multiple assignments for the command line tool,
 * i.e. ", ".
 *
 * @param commandAssignmentDelimeter
 */
public void setCommandAssignmentDelimeter(String commandAssignmentDelimeter) {
    this.commandAssignmentDelimeter = commandAssignmentDelimeter;
}

/**
 * Sets the assignment operator for the command line tool, i.e. "=".
 *
 * @param commandAssignmentOperator
 */
public void setCommandAssignmentOperator(String commandAssignmentOperator) {
    this.commandAssignmentOperator = commandAssignmentOperator;
}

/**
 * Sets the map of Metadata keys to command line parameters. Set this to
 * null to disable Metadata embedding.
 *
 * @param arguments
 */
public void setMetadataCommandArguments(Map<Property, String[]> arguments) {
    this.metadataCommandArguments = arguments;
}

/**
 * Sets whether or not to quote assignment values, i.e. tag='value'.
 *
 * @param quoteAssignmentValues
 */
public void setQuoteAssignmentValues(boolean quoteAssignmentValues) {
    this.quoteAssignmentValues = quoteAssignmentValues;
}

public void setSupportedEmbedTypes(Set<MediaType> supportedEmbedTypes) {
    this.supportedEmbedTypes = Collections.unmodifiableSet(new HashSet<>(supportedEmbedTypes));
}
```
imports: org.apache.commons.io.IOUtils, org.apache.commons.io.output.AbstractByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.Builder, org.apache.tika.exception.TikaException, org.apache.tika.io.TemporaryResources, org.apache.tika.io.TikaInputStream, org.apache.tika.metadata.Metadata, org.apache.tika.metadata.Property, org.apache.tika.mime.MediaType, org.apache.tika.parser.ParseContext, org.apache.tika.parser.external.ExternalParser

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.embedder
- class name MUST be: ExternalEmbedderembed_IOUtilscopyFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):



====================================================================================================
TEST CASE 17/24 — ITERATION 2
Entry Point: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
Third Party Method: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
thirdPartyMethod: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
path: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext) -> org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
methodSources:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) {
            sendStdOutToOutputStream(process, outputStream);
        } else // PATH: Test should invoke the next IOUtils.copy(...) [step in execution path]
        {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}
```
constructors:
```java
ExternalEmbedder() {
}
```
fieldDeclarations:
```java
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_TOKEN = "${METADATA}";
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN = "${METADATA_SERIALIZED}";
private static final long serialVersionUID = -2828829275642475697L;
private final TemporaryResources tmp = new TemporaryResources();
/**
 * Media types supported by the external program.
 */
private Set<MediaType> supportedEmbedTypes = Collections.emptySet();
/**
 * Mapping of Tika metadata to command line parameters.
 */
private Map<Property, String[]> metadataCommandArguments = null;
/**
 * The external command to invoke.
 *
 * @see Runtime#exec(String[])
 */
private String[] command = new String[]{ "sed", "-e", "$a\\
" + METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, ExternalParser.INPUT_FILE_TOKEN };
private String commandAssignmentOperator = "=";
private String commandAssignmentDelimeter = ", ";
private String commandAppendOperator = "=";
private boolean quoteAssignmentValues = false;
```
setters:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) {
            sendStdOutToOutputStream(process, outputStream);
        } else {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}

/**
 * Sets the command to be run. This can include either of
 * {@link ExternalParser#INPUT_FILE_TOKEN} or
 * {@link ExternalParser#OUTPUT_FILE_TOKEN} if the command
 * needs filenames.
 *
 * @see Runtime#exec(String[])
 */
public void setCommand(String... command) {
    this.command = command;
}

/**
 * Sets the operator to append rather than replace a value for the command
 * line tool, i.e. "+=".
 *
 * @param commandAppendOperator
 */
public void setCommandAppendOperator(String commandAppendOperator) {
    this.commandAppendOperator = commandAppendOperator;
}

/**
 * Sets the delimiter for multiple assignments for the command line tool,
 * i.e. ", ".
 *
 * @param commandAssignmentDelimeter
 */
public void setCommandAssignmentDelimeter(String commandAssignmentDelimeter) {
    this.commandAssignmentDelimeter = commandAssignmentDelimeter;
}

/**
 * Sets the assignment operator for the command line tool, i.e. "=".
 *
 * @param commandAssignmentOperator
 */
public void setCommandAssignmentOperator(String commandAssignmentOperator) {
    this.commandAssignmentOperator = commandAssignmentOperator;
}

/**
 * Sets the map of Metadata keys to command line parameters. Set this to
 * null to disable Metadata embedding.
 *
 * @param arguments
 */
public void setMetadataCommandArguments(Map<Property, String[]> arguments) {
    this.metadataCommandArguments = arguments;
}

/**
 * Sets whether or not to quote assignment values, i.e. tag='value'.
 *
 * @param quoteAssignmentValues
 */
public void setQuoteAssignmentValues(boolean quoteAssignmentValues) {
    this.quoteAssignmentValues = quoteAssignmentValues;
}

public void setSupportedEmbedTypes(Set<MediaType> supportedEmbedTypes) {
    this.supportedEmbedTypes = Collections.unmodifiableSet(new HashSet<>(supportedEmbedTypes));
}
```
imports: org.apache.commons.io.IOUtils, org.apache.commons.io.output.AbstractByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.Builder, org.apache.tika.exception.TikaException, org.apache.tika.io.TemporaryResources, org.apache.tika.io.TikaInputStream, org.apache.tika.metadata.Metadata, org.apache.tika.metadata.Property, org.apache.tika.mime.MediaType, org.apache.tika.parser.ParseContext, org.apache.tika.parser.external.ExternalParser

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.embedder
- class name MUST be: ExternalEmbedderembed_IOUtilscopyFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
TEST FAILURES DETECTED
================================================================================

[ERROR] Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 0.772 s <<< FAILURE! -- in org.apache.tika.embedder.ExternalEmbedderembed_IOUtilscopyFikaTest
[ERROR] org.apache.tika.embedder.ExternalEmbedderembed_IOUtilscopyFikaTest.testEmbedPathToIOUtilsCopy -- Time elapsed: 0.735 s <<< ERROR!
java.nio.file.NoSuchFileException: /tmp/apache-tika-11728707974462708965.tmp
	at java.base/sun.nio.fs.UnixException.translateToIOException(UnixException.java:92)
	at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:106)
	at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:111)
[ERROR] org.apache.tika.embedder.ExternalEmbedderembed_IOUtilscopyFikaTest.testEmbedPathToIOUtilsCopy -- Time elapsed: 0.735 s <<< ERROR!
java.nio.file.NoSuchFileException: /tmp/apache-tika-11728707974462708965.tmp
	at java.base/sun.nio.fs.UnixException.translateToIOException(UnixException.java:92)
	at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:106)
	at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:111)
	at java.base/sun.nio.fs.UnixFileAttributeViews$Basic.readAttributes(UnixFileAttributeViews.java:55)

================================================================================



====================================================================================================
TEST CASE 17/24 — ITERATION 3
Entry Point: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
Third Party Method: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
thirdPartyMethod: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
path: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext) -> org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
methodSources:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) {
            sendStdOutToOutputStream(process, outputStream);
        } else // PATH: Test should invoke the next IOUtils.copy(...) [step in execution path]
        {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}
```
constructors:
```java
ExternalEmbedder() {
}
```
fieldDeclarations:
```java
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_TOKEN = "${METADATA}";
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN = "${METADATA_SERIALIZED}";
private static final long serialVersionUID = -2828829275642475697L;
private final TemporaryResources tmp = new TemporaryResources();
/**
 * Media types supported by the external program.
 */
private Set<MediaType> supportedEmbedTypes = Collections.emptySet();
/**
 * Mapping of Tika metadata to command line parameters.
 */
private Map<Property, String[]> metadataCommandArguments = null;
/**
 * The external command to invoke.
 *
 * @see Runtime#exec(String[])
 */
private String[] command = new String[]{ "sed", "-e", "$a\\
" + METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, ExternalParser.INPUT_FILE_TOKEN };
private String commandAssignmentOperator = "=";
private String commandAssignmentDelimeter = ", ";
private String commandAppendOperator = "=";
private boolean quoteAssignmentValues = false;
```
setters:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) {
            sendStdOutToOutputStream(process, outputStream);
        } else {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}

/**
 * Sets the command to be run. This can include either of
 * {@link ExternalParser#INPUT_FILE_TOKEN} or
 * {@link ExternalParser#OUTPUT_FILE_TOKEN} if the command
 * needs filenames.
 *
 * @see Runtime#exec(String[])
 */
public void setCommand(String... command) {
    this.command = command;
}

/**
 * Sets the operator to append rather than replace a value for the command
 * line tool, i.e. "+=".
 *
 * @param commandAppendOperator
 */
public void setCommandAppendOperator(String commandAppendOperator) {
    this.commandAppendOperator = commandAppendOperator;
}

/**
 * Sets the delimiter for multiple assignments for the command line tool,
 * i.e. ", ".
 *
 * @param commandAssignmentDelimeter
 */
public void setCommandAssignmentDelimeter(String commandAssignmentDelimeter) {
    this.commandAssignmentDelimeter = commandAssignmentDelimeter;
}

/**
 * Sets the assignment operator for the command line tool, i.e. "=".
 *
 * @param commandAssignmentOperator
 */
public void setCommandAssignmentOperator(String commandAssignmentOperator) {
    this.commandAssignmentOperator = commandAssignmentOperator;
}

/**
 * Sets the map of Metadata keys to command line parameters. Set this to
 * null to disable Metadata embedding.
 *
 * @param arguments
 */
public void setMetadataCommandArguments(Map<Property, String[]> arguments) {
    this.metadataCommandArguments = arguments;
}

/**
 * Sets whether or not to quote assignment values, i.e. tag='value'.
 *
 * @param quoteAssignmentValues
 */
public void setQuoteAssignmentValues(boolean quoteAssignmentValues) {
    this.quoteAssignmentValues = quoteAssignmentValues;
}

public void setSupportedEmbedTypes(Set<MediaType> supportedEmbedTypes) {
    this.supportedEmbedTypes = Collections.unmodifiableSet(new HashSet<>(supportedEmbedTypes));
}
```
imports: org.apache.commons.io.IOUtils, org.apache.commons.io.output.AbstractByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.Builder, org.apache.tika.exception.TikaException, org.apache.tika.io.TemporaryResources, org.apache.tika.io.TikaInputStream, org.apache.tika.metadata.Metadata, org.apache.tika.metadata.Property, org.apache.tika.mime.MediaType, org.apache.tika.parser.ParseContext, org.apache.tika.parser.external.ExternalParser

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.embedder
- class name MUST be: ExternalEmbedderembed_IOUtilscopyFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/embedder/ExternalEmbedderembed_IOUtilscopyFikaTest.java:[26,13] cannot find symbol
  symbol:   variable ExternalParser
  location: class org.apache.tika.embedder.ExternalEmbedderembed_IOUtilscopyFikaTest
[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/embedder/ExternalEmbedderembed_IOUtilscopyFikaTest.java:[27,13] cannot find symbol
  symbol:   variable ExternalParser
  location: class org.apache.tika.embedder.ExternalEmbedderembed_IOUtilscopyFikaTest

================================================================================



====================================================================================================
TEST CASE 17/24 — ITERATION 4
Entry Point: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
Third Party Method: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
thirdPartyMethod: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
path: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext) -> org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
methodSources:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) {
            sendStdOutToOutputStream(process, outputStream);
        } else // PATH: Test should invoke the next IOUtils.copy(...) [step in execution path]
        {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}
```
constructors:
```java
ExternalEmbedder() {
}
```
fieldDeclarations:
```java
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_TOKEN = "${METADATA}";
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN = "${METADATA_SERIALIZED}";
private static final long serialVersionUID = -2828829275642475697L;
private final TemporaryResources tmp = new TemporaryResources();
/**
 * Media types supported by the external program.
 */
private Set<MediaType> supportedEmbedTypes = Collections.emptySet();
/**
 * Mapping of Tika metadata to command line parameters.
 */
private Map<Property, String[]> metadataCommandArguments = null;
/**
 * The external command to invoke.
 *
 * @see Runtime#exec(String[])
 */
private String[] command = new String[]{ "sed", "-e", "$a\\
" + METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, ExternalParser.INPUT_FILE_TOKEN };
private String commandAssignmentOperator = "=";
private String commandAssignmentDelimeter = ", ";
private String commandAppendOperator = "=";
private boolean quoteAssignmentValues = false;
```
setters:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) {
            sendStdOutToOutputStream(process, outputStream);
        } else {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}

/**
 * Sets the command to be run. This can include either of
 * {@link ExternalParser#INPUT_FILE_TOKEN} or
 * {@link ExternalParser#OUTPUT_FILE_TOKEN} if the command
 * needs filenames.
 *
 * @see Runtime#exec(String[])
 */
public void setCommand(String... command) {
    this.command = command;
}

/**
 * Sets the operator to append rather than replace a value for the command
 * line tool, i.e. "+=".
 *
 * @param commandAppendOperator
 */
public void setCommandAppendOperator(String commandAppendOperator) {
    this.commandAppendOperator = commandAppendOperator;
}

/**
 * Sets the delimiter for multiple assignments for the command line tool,
 * i.e. ", ".
 *
 * @param commandAssignmentDelimeter
 */
public void setCommandAssignmentDelimeter(String commandAssignmentDelimeter) {
    this.commandAssignmentDelimeter = commandAssignmentDelimeter;
}

/**
 * Sets the assignment operator for the command line tool, i.e. "=".
 *
 * @param commandAssignmentOperator
 */
public void setCommandAssignmentOperator(String commandAssignmentOperator) {
    this.commandAssignmentOperator = commandAssignmentOperator;
}

/**
 * Sets the map of Metadata keys to command line parameters. Set this to
 * null to disable Metadata embedding.
 *
 * @param arguments
 */
public void setMetadataCommandArguments(Map<Property, String[]> arguments) {
    this.metadataCommandArguments = arguments;
}

/**
 * Sets whether or not to quote assignment values, i.e. tag='value'.
 *
 * @param quoteAssignmentValues
 */
public void setQuoteAssignmentValues(boolean quoteAssignmentValues) {
    this.quoteAssignmentValues = quoteAssignmentValues;
}

public void setSupportedEmbedTypes(Set<MediaType> supportedEmbedTypes) {
    this.supportedEmbedTypes = Collections.unmodifiableSet(new HashSet<>(supportedEmbedTypes));
}
```
imports: org.apache.commons.io.IOUtils, org.apache.commons.io.output.AbstractByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.Builder, org.apache.tika.exception.TikaException, org.apache.tika.io.TemporaryResources, org.apache.tika.io.TikaInputStream, org.apache.tika.metadata.Metadata, org.apache.tika.metadata.Property, org.apache.tika.mime.MediaType, org.apache.tika.parser.ParseContext, org.apache.tika.parser.external.ExternalParser

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.embedder
- class name MUST be: ExternalEmbedderembed_IOUtilscopyFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
TEST FAILURES DETECTED
================================================================================

[ERROR] Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 1.026 s <<< FAILURE! -- in org.apache.tika.embedder.ExternalEmbedderembed_IOUtilscopyFikaTest
[ERROR] org.apache.tika.embedder.ExternalEmbedderembed_IOUtilscopyFikaTest.testEmbedPathToIOUtilsCopy -- Time elapsed: 0.974 s <<< ERROR!
java.nio.file.NoSuchFileException: /tmp/apache-tika-499223563246814962.tmp
	at java.base/sun.nio.fs.UnixException.translateToIOException(UnixException.java:92)
	at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:106)
	at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:111)
[ERROR] org.apache.tika.embedder.ExternalEmbedderembed_IOUtilscopyFikaTest.testEmbedPathToIOUtilsCopy -- Time elapsed: 0.974 s <<< ERROR!
java.nio.file.NoSuchFileException: /tmp/apache-tika-499223563246814962.tmp
	at java.base/sun.nio.fs.UnixException.translateToIOException(UnixException.java:92)
	at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:106)
	at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:111)
	at java.base/sun.nio.fs.UnixFileAttributeViews$Basic.readAttributes(UnixFileAttributeViews.java:55)

================================================================================



====================================================================================================
TEST CASE 17/24 — ITERATION 5
Entry Point: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
Third Party Method: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
thirdPartyMethod: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
path: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext) -> org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
methodSources:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) {
            sendStdOutToOutputStream(process, outputStream);
        } else // PATH: Test should invoke the next IOUtils.copy(...) [step in execution path]
        {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}
```
constructors:
```java
ExternalEmbedder() {
}
```
fieldDeclarations:
```java
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_TOKEN = "${METADATA}";
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN = "${METADATA_SERIALIZED}";
private static final long serialVersionUID = -2828829275642475697L;
private final TemporaryResources tmp = new TemporaryResources();
/**
 * Media types supported by the external program.
 */
private Set<MediaType> supportedEmbedTypes = Collections.emptySet();
/**
 * Mapping of Tika metadata to command line parameters.
 */
private Map<Property, String[]> metadataCommandArguments = null;
/**
 * The external command to invoke.
 *
 * @see Runtime#exec(String[])
 */
private String[] command = new String[]{ "sed", "-e", "$a\\
" + METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, ExternalParser.INPUT_FILE_TOKEN };
private String commandAssignmentOperator = "=";
private String commandAssignmentDelimeter = ", ";
private String commandAppendOperator = "=";
private boolean quoteAssignmentValues = false;
```
setters:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) {
            sendStdOutToOutputStream(process, outputStream);
        } else {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}

/**
 * Sets the command to be run. This can include either of
 * {@link ExternalParser#INPUT_FILE_TOKEN} or
 * {@link ExternalParser#OUTPUT_FILE_TOKEN} if the command
 * needs filenames.
 *
 * @see Runtime#exec(String[])
 */
public void setCommand(String... command) {
    this.command = command;
}

/**
 * Sets the operator to append rather than replace a value for the command
 * line tool, i.e. "+=".
 *
 * @param commandAppendOperator
 */
public void setCommandAppendOperator(String commandAppendOperator) {
    this.commandAppendOperator = commandAppendOperator;
}

/**
 * Sets the delimiter for multiple assignments for the command line tool,
 * i.e. ", ".
 *
 * @param commandAssignmentDelimeter
 */
public void setCommandAssignmentDelimeter(String commandAssignmentDelimeter) {
    this.commandAssignmentDelimeter = commandAssignmentDelimeter;
}

/**
 * Sets the assignment operator for the command line tool, i.e. "=".
 *
 * @param commandAssignmentOperator
 */
public void setCommandAssignmentOperator(String commandAssignmentOperator) {
    this.commandAssignmentOperator = commandAssignmentOperator;
}

/**
 * Sets the map of Metadata keys to command line parameters. Set this to
 * null to disable Metadata embedding.
 *
 * @param arguments
 */
public void setMetadataCommandArguments(Map<Property, String[]> arguments) {
    this.metadataCommandArguments = arguments;
}

/**
 * Sets whether or not to quote assignment values, i.e. tag='value'.
 *
 * @param quoteAssignmentValues
 */
public void setQuoteAssignmentValues(boolean quoteAssignmentValues) {
    this.quoteAssignmentValues = quoteAssignmentValues;
}

public void setSupportedEmbedTypes(Set<MediaType> supportedEmbedTypes) {
    this.supportedEmbedTypes = Collections.unmodifiableSet(new HashSet<>(supportedEmbedTypes));
}
```
imports: org.apache.commons.io.IOUtils, org.apache.commons.io.output.AbstractByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.Builder, org.apache.tika.exception.TikaException, org.apache.tika.io.TemporaryResources, org.apache.tika.io.TikaInputStream, org.apache.tika.metadata.Metadata, org.apache.tika.metadata.Property, org.apache.tika.mime.MediaType, org.apache.tika.parser.ParseContext, org.apache.tika.parser.external.ExternalParser

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.embedder
- class name MUST be: ExternalEmbedderembed_IOUtilscopyFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
TEST FAILURES DETECTED
================================================================================

[ERROR] Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 1.148 s <<< FAILURE! -- in org.apache.tika.embedder.ExternalEmbedderembed_IOUtilscopyFikaTest
[ERROR] org.apache.tika.embedder.ExternalEmbedderembed_IOUtilscopyFikaTest.testEmbedPathToIOUtilsCopy -- Time elapsed: 1.100 s <<< ERROR!
java.nio.file.NoSuchFileException: /tmp/apache-tika-14833957046849300074.tmp
	at java.base/sun.nio.fs.UnixException.translateToIOException(UnixException.java:92)
	at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:106)
	at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:111)
[ERROR] org.apache.tika.embedder.ExternalEmbedderembed_IOUtilscopyFikaTest.testEmbedPathToIOUtilsCopy -- Time elapsed: 1.100 s <<< ERROR!
java.nio.file.NoSuchFileException: /tmp/apache-tika-14833957046849300074.tmp
	at java.base/sun.nio.fs.UnixException.translateToIOException(UnixException.java:92)
	at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:106)
	at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:111)
	at java.base/sun.nio.fs.UnixFileAttributeViews$Basic.readAttributes(UnixFileAttributeViews.java:55)

================================================================================



====================================================================================================
TEST CASE 18/24 — ITERATION 1
Entry Point: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
Third Party Method: org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.builder()
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
thirdPartyMethod: org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.builder()
path: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext) -> org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.builder()
methodSources:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = // PATH: Test should invoke the next UnsynchronizedByteArrayOutputStream.builder(...) [step in execution path]
    UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) {
            sendStdOutToOutputStream(process, outputStream);
        } else {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}
```
constructors:
```java
ExternalEmbedder() {
}
```
fieldDeclarations:
```java
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_TOKEN = "${METADATA}";
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN = "${METADATA_SERIALIZED}";
private static final long serialVersionUID = -2828829275642475697L;
private final TemporaryResources tmp = new TemporaryResources();
/**
 * Media types supported by the external program.
 */
private Set<MediaType> supportedEmbedTypes = Collections.emptySet();
/**
 * Mapping of Tika metadata to command line parameters.
 */
private Map<Property, String[]> metadataCommandArguments = null;
/**
 * The external command to invoke.
 *
 * @see Runtime#exec(String[])
 */
private String[] command = new String[]{ "sed", "-e", "$a\\
" + METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, ExternalParser.INPUT_FILE_TOKEN };
private String commandAssignmentOperator = "=";
private String commandAssignmentDelimeter = ", ";
private String commandAppendOperator = "=";
private boolean quoteAssignmentValues = false;
```
setters:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) {
            sendStdOutToOutputStream(process, outputStream);
        } else {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}

/**
 * Sets the command to be run. This can include either of
 * {@link ExternalParser#INPUT_FILE_TOKEN} or
 * {@link ExternalParser#OUTPUT_FILE_TOKEN} if the command
 * needs filenames.
 *
 * @see Runtime#exec(String[])
 */
public void setCommand(String... command) {
    this.command = command;
}

/**
 * Sets the operator to append rather than replace a value for the command
 * line tool, i.e. "+=".
 *
 * @param commandAppendOperator
 */
public void setCommandAppendOperator(String commandAppendOperator) {
    this.commandAppendOperator = commandAppendOperator;
}

/**
 * Sets the delimiter for multiple assignments for the command line tool,
 * i.e. ", ".
 *
 * @param commandAssignmentDelimeter
 */
public void setCommandAssignmentDelimeter(String commandAssignmentDelimeter) {
    this.commandAssignmentDelimeter = commandAssignmentDelimeter;
}

/**
 * Sets the assignment operator for the command line tool, i.e. "=".
 *
 * @param commandAssignmentOperator
 */
public void setCommandAssignmentOperator(String commandAssignmentOperator) {
    this.commandAssignmentOperator = commandAssignmentOperator;
}

/**
 * Sets the map of Metadata keys to command line parameters. Set this to
 * null to disable Metadata embedding.
 *
 * @param arguments
 */
public void setMetadataCommandArguments(Map<Property, String[]> arguments) {
    this.metadataCommandArguments = arguments;
}

/**
 * Sets whether or not to quote assignment values, i.e. tag='value'.
 *
 * @param quoteAssignmentValues
 */
public void setQuoteAssignmentValues(boolean quoteAssignmentValues) {
    this.quoteAssignmentValues = quoteAssignmentValues;
}

public void setSupportedEmbedTypes(Set<MediaType> supportedEmbedTypes) {
    this.supportedEmbedTypes = Collections.unmodifiableSet(new HashSet<>(supportedEmbedTypes));
}
```
imports: org.apache.commons.io.IOUtils, org.apache.commons.io.output.AbstractByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.Builder, org.apache.tika.exception.TikaException, org.apache.tika.io.TemporaryResources, org.apache.tika.io.TikaInputStream, org.apache.tika.metadata.Metadata, org.apache.tika.metadata.Property, org.apache.tika.mime.MediaType, org.apache.tika.parser.ParseContext, org.apache.tika.parser.external.ExternalParser

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.embedder
- class name MUST be: ExternalEmbedderembed_UnsynchronizedByteArrayOutputStreambuilderFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):



====================================================================================================
TEST CASE 19/24 — ITERATION 1
Entry Point: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
Third Party Method: org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.toString(java.lang.String)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
thirdPartyMethod: org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.toString(java.lang.String)
path: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext) -> org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.toString(java.lang.String)
methodSources:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) {
            sendStdOutToOutputStream(process, outputStream);
        } else {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}
```
constructors:
```java
ExternalEmbedder() {
}
```
fieldDeclarations:
```java
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_TOKEN = "${METADATA}";
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN = "${METADATA_SERIALIZED}";
private static final long serialVersionUID = -2828829275642475697L;
private final TemporaryResources tmp = new TemporaryResources();
/**
 * Media types supported by the external program.
 */
private Set<MediaType> supportedEmbedTypes = Collections.emptySet();
/**
 * Mapping of Tika metadata to command line parameters.
 */
private Map<Property, String[]> metadataCommandArguments = null;
/**
 * The external command to invoke.
 *
 * @see Runtime#exec(String[])
 */
private String[] command = new String[]{ "sed", "-e", "$a\\
" + METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, ExternalParser.INPUT_FILE_TOKEN };
private String commandAssignmentOperator = "=";
private String commandAssignmentDelimeter = ", ";
private String commandAppendOperator = "=";
private boolean quoteAssignmentValues = false;
```
setters:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) {
            sendStdOutToOutputStream(process, outputStream);
        } else {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}

/**
 * Sets the command to be run. This can include either of
 * {@link ExternalParser#INPUT_FILE_TOKEN} or
 * {@link ExternalParser#OUTPUT_FILE_TOKEN} if the command
 * needs filenames.
 *
 * @see Runtime#exec(String[])
 */
public void setCommand(String... command) {
    this.command = command;
}

/**
 * Sets the operator to append rather than replace a value for the command
 * line tool, i.e. "+=".
 *
 * @param commandAppendOperator
 */
public void setCommandAppendOperator(String commandAppendOperator) {
    this.commandAppendOperator = commandAppendOperator;
}

/**
 * Sets the delimiter for multiple assignments for the command line tool,
 * i.e. ", ".
 *
 * @param commandAssignmentDelimeter
 */
public void setCommandAssignmentDelimeter(String commandAssignmentDelimeter) {
    this.commandAssignmentDelimeter = commandAssignmentDelimeter;
}

/**
 * Sets the assignment operator for the command line tool, i.e. "=".
 *
 * @param commandAssignmentOperator
 */
public void setCommandAssignmentOperator(String commandAssignmentOperator) {
    this.commandAssignmentOperator = commandAssignmentOperator;
}

/**
 * Sets the map of Metadata keys to command line parameters. Set this to
 * null to disable Metadata embedding.
 *
 * @param arguments
 */
public void setMetadataCommandArguments(Map<Property, String[]> arguments) {
    this.metadataCommandArguments = arguments;
}

/**
 * Sets whether or not to quote assignment values, i.e. tag='value'.
 *
 * @param quoteAssignmentValues
 */
public void setQuoteAssignmentValues(boolean quoteAssignmentValues) {
    this.quoteAssignmentValues = quoteAssignmentValues;
}

public void setSupportedEmbedTypes(Set<MediaType> supportedEmbedTypes) {
    this.supportedEmbedTypes = Collections.unmodifiableSet(new HashSet<>(supportedEmbedTypes));
}
```
imports: org.apache.commons.io.IOUtils, org.apache.commons.io.output.AbstractByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.Builder, org.apache.tika.exception.TikaException, org.apache.tika.io.TemporaryResources, org.apache.tika.io.TikaInputStream, org.apache.tika.metadata.Metadata, org.apache.tika.metadata.Property, org.apache.tika.mime.MediaType, org.apache.tika.parser.ParseContext, org.apache.tika.parser.external.ExternalParser

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.embedder
- class name MUST be: ExternalEmbedderembed_UnsynchronizedByteArrayOutputStreamtoStringFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):



====================================================================================================
TEST CASE 19/24 — ITERATION 2
Entry Point: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
Third Party Method: org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.toString(java.lang.String)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
thirdPartyMethod: org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.toString(java.lang.String)
path: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext) -> org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.toString(java.lang.String)
methodSources:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) {
            sendStdOutToOutputStream(process, outputStream);
        } else {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}
```
constructors:
```java
ExternalEmbedder() {
}
```
fieldDeclarations:
```java
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_TOKEN = "${METADATA}";
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN = "${METADATA_SERIALIZED}";
private static final long serialVersionUID = -2828829275642475697L;
private final TemporaryResources tmp = new TemporaryResources();
/**
 * Media types supported by the external program.
 */
private Set<MediaType> supportedEmbedTypes = Collections.emptySet();
/**
 * Mapping of Tika metadata to command line parameters.
 */
private Map<Property, String[]> metadataCommandArguments = null;
/**
 * The external command to invoke.
 *
 * @see Runtime#exec(String[])
 */
private String[] command = new String[]{ "sed", "-e", "$a\\
" + METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, ExternalParser.INPUT_FILE_TOKEN };
private String commandAssignmentOperator = "=";
private String commandAssignmentDelimeter = ", ";
private String commandAppendOperator = "=";
private boolean quoteAssignmentValues = false;
```
setters:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) {
            sendStdOutToOutputStream(process, outputStream);
        } else {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}

/**
 * Sets the command to be run. This can include either of
 * {@link ExternalParser#INPUT_FILE_TOKEN} or
 * {@link ExternalParser#OUTPUT_FILE_TOKEN} if the command
 * needs filenames.
 *
 * @see Runtime#exec(String[])
 */
public void setCommand(String... command) {
    this.command = command;
}

/**
 * Sets the operator to append rather than replace a value for the command
 * line tool, i.e. "+=".
 *
 * @param commandAppendOperator
 */
public void setCommandAppendOperator(String commandAppendOperator) {
    this.commandAppendOperator = commandAppendOperator;
}

/**
 * Sets the delimiter for multiple assignments for the command line tool,
 * i.e. ", ".
 *
 * @param commandAssignmentDelimeter
 */
public void setCommandAssignmentDelimeter(String commandAssignmentDelimeter) {
    this.commandAssignmentDelimeter = commandAssignmentDelimeter;
}

/**
 * Sets the assignment operator for the command line tool, i.e. "=".
 *
 * @param commandAssignmentOperator
 */
public void setCommandAssignmentOperator(String commandAssignmentOperator) {
    this.commandAssignmentOperator = commandAssignmentOperator;
}

/**
 * Sets the map of Metadata keys to command line parameters. Set this to
 * null to disable Metadata embedding.
 *
 * @param arguments
 */
public void setMetadataCommandArguments(Map<Property, String[]> arguments) {
    this.metadataCommandArguments = arguments;
}

/**
 * Sets whether or not to quote assignment values, i.e. tag='value'.
 *
 * @param quoteAssignmentValues
 */
public void setQuoteAssignmentValues(boolean quoteAssignmentValues) {
    this.quoteAssignmentValues = quoteAssignmentValues;
}

public void setSupportedEmbedTypes(Set<MediaType> supportedEmbedTypes) {
    this.supportedEmbedTypes = Collections.unmodifiableSet(new HashSet<>(supportedEmbedTypes));
}
```
imports: org.apache.commons.io.IOUtils, org.apache.commons.io.output.AbstractByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.Builder, org.apache.tika.exception.TikaException, org.apache.tika.io.TemporaryResources, org.apache.tika.io.TikaInputStream, org.apache.tika.metadata.Metadata, org.apache.tika.metadata.Property, org.apache.tika.mime.MediaType, org.apache.tika.parser.ParseContext, org.apache.tika.parser.external.ExternalParser

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.embedder
- class name MUST be: ExternalEmbedderembed_UnsynchronizedByteArrayOutputStreamtoStringFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
TEST FAILURES DETECTED
================================================================================

[ERROR] Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 0.709 s <<< FAILURE! -- in org.apache.tika.embedder.ExternalEmbedderembed_UnsynchronizedByteArrayOutputStreamtoStringFikaTest
[ERROR] org.apache.tika.embedder.ExternalEmbedderembed_UnsynchronizedByteArrayOutputStreamtoStringFikaTest.test -- Time elapsed: 0.674 s <<< ERROR!
java.io.IOException: Cannot run program "nonexistent_command_xyz123": error=2, No such file or directory
	at java.base/java.lang.ProcessBuilder.start(ProcessBuilder.java:1143)
	at java.base/java.lang.ProcessBuilder.start(ProcessBuilder.java:1073)
	at java.base/java.lang.Runtime.exec(Runtime.java:594)
[ERROR] org.apache.tika.embedder.ExternalEmbedderembed_UnsynchronizedByteArrayOutputStreamtoStringFikaTest.test -- Time elapsed: 0.674 s <<< ERROR!
java.io.IOException: Cannot run program "nonexistent_command_xyz123": error=2, No such file or directory
	at java.base/java.lang.ProcessBuilder.start(ProcessBuilder.java:1143)
	at java.base/java.lang.ProcessBuilder.start(ProcessBuilder.java:1073)
	at java.base/java.lang.Runtime.exec(Runtime.java:594)
	at java.base/java.lang.Runtime.exec(Runtime.java:418)

================================================================================



====================================================================================================
TEST CASE 19/24 — ITERATION 3
Entry Point: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
Third Party Method: org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.toString(java.lang.String)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
thirdPartyMethod: org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.toString(java.lang.String)
path: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext) -> org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.toString(java.lang.String)
methodSources:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) {
            sendStdOutToOutputStream(process, outputStream);
        } else {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}
```
constructors:
```java
ExternalEmbedder() {
}
```
fieldDeclarations:
```java
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_TOKEN = "${METADATA}";
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN = "${METADATA_SERIALIZED}";
private static final long serialVersionUID = -2828829275642475697L;
private final TemporaryResources tmp = new TemporaryResources();
/**
 * Media types supported by the external program.
 */
private Set<MediaType> supportedEmbedTypes = Collections.emptySet();
/**
 * Mapping of Tika metadata to command line parameters.
 */
private Map<Property, String[]> metadataCommandArguments = null;
/**
 * The external command to invoke.
 *
 * @see Runtime#exec(String[])
 */
private String[] command = new String[]{ "sed", "-e", "$a\\
" + METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, ExternalParser.INPUT_FILE_TOKEN };
private String commandAssignmentOperator = "=";
private String commandAssignmentDelimeter = ", ";
private String commandAppendOperator = "=";
private boolean quoteAssignmentValues = false;
```
setters:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) {
            sendStdOutToOutputStream(process, outputStream);
        } else {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}

/**
 * Sets the command to be run. This can include either of
 * {@link ExternalParser#INPUT_FILE_TOKEN} or
 * {@link ExternalParser#OUTPUT_FILE_TOKEN} if the command
 * needs filenames.
 *
 * @see Runtime#exec(String[])
 */
public void setCommand(String... command) {
    this.command = command;
}

/**
 * Sets the operator to append rather than replace a value for the command
 * line tool, i.e. "+=".
 *
 * @param commandAppendOperator
 */
public void setCommandAppendOperator(String commandAppendOperator) {
    this.commandAppendOperator = commandAppendOperator;
}

/**
 * Sets the delimiter for multiple assignments for the command line tool,
 * i.e. ", ".
 *
 * @param commandAssignmentDelimeter
 */
public void setCommandAssignmentDelimeter(String commandAssignmentDelimeter) {
    this.commandAssignmentDelimeter = commandAssignmentDelimeter;
}

/**
 * Sets the assignment operator for the command line tool, i.e. "=".
 *
 * @param commandAssignmentOperator
 */
public void setCommandAssignmentOperator(String commandAssignmentOperator) {
    this.commandAssignmentOperator = commandAssignmentOperator;
}

/**
 * Sets the map of Metadata keys to command line parameters. Set this to
 * null to disable Metadata embedding.
 *
 * @param arguments
 */
public void setMetadataCommandArguments(Map<Property, String[]> arguments) {
    this.metadataCommandArguments = arguments;
}

/**
 * Sets whether or not to quote assignment values, i.e. tag='value'.
 *
 * @param quoteAssignmentValues
 */
public void setQuoteAssignmentValues(boolean quoteAssignmentValues) {
    this.quoteAssignmentValues = quoteAssignmentValues;
}

public void setSupportedEmbedTypes(Set<MediaType> supportedEmbedTypes) {
    this.supportedEmbedTypes = Collections.unmodifiableSet(new HashSet<>(supportedEmbedTypes));
}
```
imports: org.apache.commons.io.IOUtils, org.apache.commons.io.output.AbstractByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.Builder, org.apache.tika.exception.TikaException, org.apache.tika.io.TemporaryResources, org.apache.tika.io.TikaInputStream, org.apache.tika.metadata.Metadata, org.apache.tika.metadata.Property, org.apache.tika.mime.MediaType, org.apache.tika.parser.ParseContext, org.apache.tika.parser.external.ExternalParser

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.embedder
- class name MUST be: ExternalEmbedderembed_UnsynchronizedByteArrayOutputStreamtoStringFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COVERAGE CHECK FAILED - Test passed but target method NOT covered
================================================================================

NOT covered methods (1):
  ✗ org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.toString(java.lang.String)

No methods in the call chain were reached.
Ensure the test properly invokes the entry point 'org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)' to reach 'org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.toString(java.lang.String)'.
================================================================================



====================================================================================================
TEST CASE 20/24 — ITERATION 1
Entry Point: org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream)
Third Party Method: org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream)
thirdPartyMethod: org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
path: org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream) -> org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream, boolean) -> org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
methodSources:
```java
/**
 *
 * @since Apache Tika 0.9
 */
public QName extractRootElement(InputStream stream) {
    // PATH: Test should invoke the next XmlRootExtractor.extractRootElement(...) [step in execution path]
    return extractRootElement(stream, false);
}

private QName extractRootElement(InputStream stream, boolean throwMalformed) {
    ExtractorHandler handler = new ExtractorHandler();
    try {
        // PATH: Test should invoke the next CloseShieldInputStream.wrap(...) [step in execution path]
        XMLReaderUtils.parseSAX(CloseShieldInputStream.wrap(stream), handler, EMPTY_CONTEXT);
    } catch (SecurityException e) {
        throw e;
    } catch (Exception e) {
        if (throwMalformed && ((e instanceof CharConversionException) || (e.getCause() instanceof CharConversionException))) {
            throw new MalformedCharException(e);
        }
    }
    return handler.rootElement;
}
```
constructors:
```java
XmlRootExtractor() {
}

ExtractorHandler() {
}

public MalformedCharException(Exception e) {
    super(e);
}
```
fieldDeclarations:
```java
private static final ParseContext EMPTY_CONTEXT = new ParseContext();
```
setters:

imports: javax.xml.namespace.QName, org.apache.commons.io.input.CloseShieldInputStream, org.apache.commons.io.input.UnsynchronizedByteArrayInputStream, org.apache.tika.detect.XmlRootExtractor.ExtractorHandler, org.apache.tika.detect.XmlRootExtractor.MalformedCharException, org.apache.tika.parser.ParseContext, org.apache.tika.utils.XMLReaderUtils, org.xml.sax.ContentHandler, org.xml.sax.helpers.DefaultHandler

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.detect
- class name MUST be: XmlRootExtractorextractRootElement_CloseShieldInputStreamwrapFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):



====================================================================================================
TEST CASE 20/24 — ITERATION 2
Entry Point: org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream)
Third Party Method: org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream)
thirdPartyMethod: org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
path: org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream) -> org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream, boolean) -> org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
methodSources:
```java
/**
 *
 * @since Apache Tika 0.9
 */
public QName extractRootElement(InputStream stream) {
    // PATH: Test should invoke the next XmlRootExtractor.extractRootElement(...) [step in execution path]
    return extractRootElement(stream, false);
}

private QName extractRootElement(InputStream stream, boolean throwMalformed) {
    ExtractorHandler handler = new ExtractorHandler();
    try {
        // PATH: Test should invoke the next CloseShieldInputStream.wrap(...) [step in execution path]
        XMLReaderUtils.parseSAX(CloseShieldInputStream.wrap(stream), handler, EMPTY_CONTEXT);
    } catch (SecurityException e) {
        throw e;
    } catch (Exception e) {
        if (throwMalformed && ((e instanceof CharConversionException) || (e.getCause() instanceof CharConversionException))) {
            throw new MalformedCharException(e);
        }
    }
    return handler.rootElement;
}
```
constructors:
```java
XmlRootExtractor() {
}

ExtractorHandler() {
}

public MalformedCharException(Exception e) {
    super(e);
}
```
fieldDeclarations:
```java
private static final ParseContext EMPTY_CONTEXT = new ParseContext();
```
setters:

imports: javax.xml.namespace.QName, org.apache.commons.io.input.CloseShieldInputStream, org.apache.commons.io.input.UnsynchronizedByteArrayInputStream, org.apache.tika.detect.XmlRootExtractor.ExtractorHandler, org.apache.tika.detect.XmlRootExtractor.MalformedCharException, org.apache.tika.parser.ParseContext, org.apache.tika.utils.XMLReaderUtils, org.xml.sax.ContentHandler, org.xml.sax.helpers.DefaultHandler

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.detect
- class name MUST be: XmlRootExtractorextractRootElement_CloseShieldInputStreamwrapFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COVERAGE CHECK FAILED - Test passed but target method NOT covered
================================================================================

Covered methods (1):
  ✓ org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream, boolean)

NOT covered methods (1):
  ✗ org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)

The call chain breaks between:
  'org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream, boolean)' → 'org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)'

Ensure 'org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream, boolean)' properly calls 'org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)'.
================================================================================



====================================================================================================
TEST CASE 20/24 — ITERATION 3
Entry Point: org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream)
Third Party Method: org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream)
thirdPartyMethod: org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
path: org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream) -> org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream, boolean) -> org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
methodSources:
```java
/**
 *
 * @since Apache Tika 0.9
 */
public QName extractRootElement(InputStream stream) {
    // PATH: Test should invoke the next XmlRootExtractor.extractRootElement(...) [step in execution path]
    return extractRootElement(stream, false);
}

private QName extractRootElement(InputStream stream, boolean throwMalformed) {
    ExtractorHandler handler = new ExtractorHandler();
    try {
        // PATH: Test should invoke the next CloseShieldInputStream.wrap(...) [step in execution path]
        XMLReaderUtils.parseSAX(CloseShieldInputStream.wrap(stream), handler, EMPTY_CONTEXT);
    } catch (SecurityException e) {
        throw e;
    } catch (Exception e) {
        if (throwMalformed && ((e instanceof CharConversionException) || (e.getCause() instanceof CharConversionException))) {
            throw new MalformedCharException(e);
        }
    }
    return handler.rootElement;
}
```
constructors:
```java
XmlRootExtractor() {
}

ExtractorHandler() {
}

public MalformedCharException(Exception e) {
    super(e);
}
```
fieldDeclarations:
```java
private static final ParseContext EMPTY_CONTEXT = new ParseContext();
```
setters:

imports: javax.xml.namespace.QName, org.apache.commons.io.input.CloseShieldInputStream, org.apache.commons.io.input.UnsynchronizedByteArrayInputStream, org.apache.tika.detect.XmlRootExtractor.ExtractorHandler, org.apache.tika.detect.XmlRootExtractor.MalformedCharException, org.apache.tika.parser.ParseContext, org.apache.tika.utils.XMLReaderUtils, org.xml.sax.ContentHandler, org.xml.sax.helpers.DefaultHandler

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.detect
- class name MUST be: XmlRootExtractorextractRootElement_CloseShieldInputStreamwrapFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):

================================================================================
HARD CONSTRAINT VALIDATION FAILED
================================================================================

HARD CONSTRAINT VIOLATION: Test contains overridden method(s).
  Found 1 @Override annotation(s).
  Requirement: Test methods must not override any methods.
  Fix: Remove all @Override annotations and ensure methods are not overriding parent methods.

  Example 1:
    utStream stream = new InputStream() {
            @Override
            public int read() {
                return -1;
            }
        };
      ...

HARD CONSTRAINT VIOLATION: Test uses anonymous inner class(es).
  Found 1 anonymous inner class(es).
  Requirement: Do not create anonymous classes that override behavior.
  Fix: Use real object instances or mock objects without overriding methods.
  Anonymous inner classes implicitly extend/override the class behavior.

  Example 1 (class: InputStream):
    ...InputStream stream = new InputStream() {             @Override             public int read() {                 return -1...

================================================================================
Please regenerate the test without these violations.
Remember:
  - The test class must be standalone (no 'extends' clause)
  - Do not override any methods (no @Override)
  - Do not create anonymous inner classes (new ClassName() {...})
  - Do not use Mockito stubbing (when/doReturn/thenReturn/etc.)
  - Do not use Mockito spy() or @Spy
  - Do not use Mockito verify() or verifications
  - All methods must execute their real, unaltered implementations
================================================================================



====================================================================================================
TEST CASE 20/24 — ITERATION 4
Entry Point: org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream)
Third Party Method: org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream)
thirdPartyMethod: org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
path: org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream) -> org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream, boolean) -> org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
methodSources:
```java
/**
 *
 * @since Apache Tika 0.9
 */
public QName extractRootElement(InputStream stream) {
    // PATH: Test should invoke the next XmlRootExtractor.extractRootElement(...) [step in execution path]
    return extractRootElement(stream, false);
}

private QName extractRootElement(InputStream stream, boolean throwMalformed) {
    ExtractorHandler handler = new ExtractorHandler();
    try {
        // PATH: Test should invoke the next CloseShieldInputStream.wrap(...) [step in execution path]
        XMLReaderUtils.parseSAX(CloseShieldInputStream.wrap(stream), handler, EMPTY_CONTEXT);
    } catch (SecurityException e) {
        throw e;
    } catch (Exception e) {
        if (throwMalformed && ((e instanceof CharConversionException) || (e.getCause() instanceof CharConversionException))) {
            throw new MalformedCharException(e);
        }
    }
    return handler.rootElement;
}
```
constructors:
```java
XmlRootExtractor() {
}

ExtractorHandler() {
}

public MalformedCharException(Exception e) {
    super(e);
}
```
fieldDeclarations:
```java
private static final ParseContext EMPTY_CONTEXT = new ParseContext();
```
setters:

imports: javax.xml.namespace.QName, org.apache.commons.io.input.CloseShieldInputStream, org.apache.commons.io.input.UnsynchronizedByteArrayInputStream, org.apache.tika.detect.XmlRootExtractor.ExtractorHandler, org.apache.tika.detect.XmlRootExtractor.MalformedCharException, org.apache.tika.parser.ParseContext, org.apache.tika.utils.XMLReaderUtils, org.xml.sax.ContentHandler, org.xml.sax.helpers.DefaultHandler

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.detect
- class name MUST be: XmlRootExtractorextractRootElement_CloseShieldInputStreamwrapFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COVERAGE CHECK FAILED - Test passed but target method NOT covered
================================================================================

Covered methods (1):
  ✓ org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream, boolean)

NOT covered methods (1):
  ✗ org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)

The call chain breaks between:
  'org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream, boolean)' → 'org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)'

Ensure 'org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream, boolean)' properly calls 'org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)'.
================================================================================



====================================================================================================
TEST CASE 20/24 — ITERATION 5
Entry Point: org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream)
Third Party Method: org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream)
thirdPartyMethod: org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
path: org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream) -> org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream, boolean) -> org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
methodSources:
```java
/**
 *
 * @since Apache Tika 0.9
 */
public QName extractRootElement(InputStream stream) {
    // PATH: Test should invoke the next XmlRootExtractor.extractRootElement(...) [step in execution path]
    return extractRootElement(stream, false);
}

private QName extractRootElement(InputStream stream, boolean throwMalformed) {
    ExtractorHandler handler = new ExtractorHandler();
    try {
        // PATH: Test should invoke the next CloseShieldInputStream.wrap(...) [step in execution path]
        XMLReaderUtils.parseSAX(CloseShieldInputStream.wrap(stream), handler, EMPTY_CONTEXT);
    } catch (SecurityException e) {
        throw e;
    } catch (Exception e) {
        if (throwMalformed && ((e instanceof CharConversionException) || (e.getCause() instanceof CharConversionException))) {
            throw new MalformedCharException(e);
        }
    }
    return handler.rootElement;
}
```
constructors:
```java
XmlRootExtractor() {
}

ExtractorHandler() {
}

public MalformedCharException(Exception e) {
    super(e);
}
```
fieldDeclarations:
```java
private static final ParseContext EMPTY_CONTEXT = new ParseContext();
```
setters:

imports: javax.xml.namespace.QName, org.apache.commons.io.input.CloseShieldInputStream, org.apache.commons.io.input.UnsynchronizedByteArrayInputStream, org.apache.tika.detect.XmlRootExtractor.ExtractorHandler, org.apache.tika.detect.XmlRootExtractor.MalformedCharException, org.apache.tika.parser.ParseContext, org.apache.tika.utils.XMLReaderUtils, org.xml.sax.ContentHandler, org.xml.sax.helpers.DefaultHandler

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.detect
- class name MUST be: XmlRootExtractorextractRootElement_CloseShieldInputStreamwrapFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/detect/XmlRootExtractorextractRootElement_CloseShieldInputStreamwrapFikaTest.java:[6,47] org.apache.tika.detect.XmlRootExtractor.ExtractorHandler has private access in org.apache.tika.detect.XmlRootExtractor
[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/detect/XmlRootExtractorextractRootElement_CloseShieldInputStreamwrapFikaTest.java:[7,47] org.apache.tika.detect.XmlRootExtractor.MalformedCharException has private access in org.apache.tika.detect.XmlRootExtractor

================================================================================



====================================================================================================
TEST CASE 21/24 — ITERATION 1
Entry Point: org.apache.tika.detect.XmlRootExtractor.extractRootElement(byte[])
Third Party Method: org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.detect.XmlRootExtractor.extractRootElement(byte[])
thirdPartyMethod: org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
path: org.apache.tika.detect.XmlRootExtractor.extractRootElement(byte[]) -> org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream, boolean) -> org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
methodSources:
```java
public QName extractRootElement(byte[] data) {
    // this loop should be very rare
    while (true) {
        try {
            // PATH: Test should invoke the next XmlRootExtractor.extractRootElement(...) [step in execution path]
            return extractRootElement(new UnsynchronizedByteArrayInputStream(data), true);
        } catch (MalformedCharException e) {
            // see TIKA-3596, try to handle truncated/bad encoded XML files
            int newLen = data.length / 2;
            if ((newLen % 2) == 1) {
                newLen--;
            }
            if (newLen > 0) {
                data = Arrays.copyOf(data, newLen);
            } else {
                break;
            }
        }
    } 
    return null;
}

private QName extractRootElement(InputStream stream, boolean throwMalformed) {
    ExtractorHandler handler = new ExtractorHandler();
    try {
        // PATH: Test should invoke the next CloseShieldInputStream.wrap(...) [step in execution path]
        XMLReaderUtils.parseSAX(CloseShieldInputStream.wrap(stream), handler, EMPTY_CONTEXT);
    } catch (SecurityException e) {
        throw e;
    } catch (Exception e) {
        if (throwMalformed && ((e instanceof CharConversionException) || (e.getCause() instanceof CharConversionException))) {
            throw new MalformedCharException(e);
        }
    }
    return handler.rootElement;
}
```
constructors:
```java
XmlRootExtractor() {
}

ExtractorHandler() {
}

public MalformedCharException(Exception e) {
    super(e);
}
```
fieldDeclarations:
```java
private static final ParseContext EMPTY_CONTEXT = new ParseContext();
```
setters:

imports: javax.xml.namespace.QName, org.apache.commons.io.input.CloseShieldInputStream, org.apache.commons.io.input.UnsynchronizedByteArrayInputStream, org.apache.tika.detect.XmlRootExtractor.ExtractorHandler, org.apache.tika.detect.XmlRootExtractor.MalformedCharException, org.apache.tika.parser.ParseContext, org.apache.tika.utils.XMLReaderUtils, org.xml.sax.ContentHandler, org.xml.sax.helpers.DefaultHandler

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.detect
- class name MUST be: XmlRootExtractorextractRootElement_CloseShieldInputStreamwrapFikaTest2
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):



====================================================================================================
TEST CASE 21/24 — ITERATION 2
Entry Point: org.apache.tika.detect.XmlRootExtractor.extractRootElement(byte[])
Third Party Method: org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.detect.XmlRootExtractor.extractRootElement(byte[])
thirdPartyMethod: org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
path: org.apache.tika.detect.XmlRootExtractor.extractRootElement(byte[]) -> org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream, boolean) -> org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
methodSources:
```java
public QName extractRootElement(byte[] data) {
    // this loop should be very rare
    while (true) {
        try {
            // PATH: Test should invoke the next XmlRootExtractor.extractRootElement(...) [step in execution path]
            return extractRootElement(new UnsynchronizedByteArrayInputStream(data), true);
        } catch (MalformedCharException e) {
            // see TIKA-3596, try to handle truncated/bad encoded XML files
            int newLen = data.length / 2;
            if ((newLen % 2) == 1) {
                newLen--;
            }
            if (newLen > 0) {
                data = Arrays.copyOf(data, newLen);
            } else {
                break;
            }
        }
    } 
    return null;
}

private QName extractRootElement(InputStream stream, boolean throwMalformed) {
    ExtractorHandler handler = new ExtractorHandler();
    try {
        // PATH: Test should invoke the next CloseShieldInputStream.wrap(...) [step in execution path]
        XMLReaderUtils.parseSAX(CloseShieldInputStream.wrap(stream), handler, EMPTY_CONTEXT);
    } catch (SecurityException e) {
        throw e;
    } catch (Exception e) {
        if (throwMalformed && ((e instanceof CharConversionException) || (e.getCause() instanceof CharConversionException))) {
            throw new MalformedCharException(e);
        }
    }
    return handler.rootElement;
}
```
constructors:
```java
XmlRootExtractor() {
}

ExtractorHandler() {
}

public MalformedCharException(Exception e) {
    super(e);
}
```
fieldDeclarations:
```java
private static final ParseContext EMPTY_CONTEXT = new ParseContext();
```
setters:

imports: javax.xml.namespace.QName, org.apache.commons.io.input.CloseShieldInputStream, org.apache.commons.io.input.UnsynchronizedByteArrayInputStream, org.apache.tika.detect.XmlRootExtractor.ExtractorHandler, org.apache.tika.detect.XmlRootExtractor.MalformedCharException, org.apache.tika.parser.ParseContext, org.apache.tika.utils.XMLReaderUtils, org.xml.sax.ContentHandler, org.xml.sax.helpers.DefaultHandler

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.detect
- class name MUST be: XmlRootExtractorextractRootElement_CloseShieldInputStreamwrapFikaTest2
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/detect/XmlRootExtractorextractRootElement_CloseShieldInputStreamwrapFikaTest2.java:[7,47] org.apache.tika.detect.XmlRootExtractor.ExtractorHandler has private access in org.apache.tika.detect.XmlRootExtractor
[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/detect/XmlRootExtractorextractRootElement_CloseShieldInputStreamwrapFikaTest2.java:[8,47] org.apache.tika.detect.XmlRootExtractor.MalformedCharException has private access in org.apache.tika.detect.XmlRootExtractor

================================================================================



====================================================================================================
TEST CASE 21/24 — ITERATION 3
Entry Point: org.apache.tika.detect.XmlRootExtractor.extractRootElement(byte[])
Third Party Method: org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.detect.XmlRootExtractor.extractRootElement(byte[])
thirdPartyMethod: org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
path: org.apache.tika.detect.XmlRootExtractor.extractRootElement(byte[]) -> org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream, boolean) -> org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
methodSources:
```java
public QName extractRootElement(byte[] data) {
    // this loop should be very rare
    while (true) {
        try {
            // PATH: Test should invoke the next XmlRootExtractor.extractRootElement(...) [step in execution path]
            return extractRootElement(new UnsynchronizedByteArrayInputStream(data), true);
        } catch (MalformedCharException e) {
            // see TIKA-3596, try to handle truncated/bad encoded XML files
            int newLen = data.length / 2;
            if ((newLen % 2) == 1) {
                newLen--;
            }
            if (newLen > 0) {
                data = Arrays.copyOf(data, newLen);
            } else {
                break;
            }
        }
    } 
    return null;
}

private QName extractRootElement(InputStream stream, boolean throwMalformed) {
    ExtractorHandler handler = new ExtractorHandler();
    try {
        // PATH: Test should invoke the next CloseShieldInputStream.wrap(...) [step in execution path]
        XMLReaderUtils.parseSAX(CloseShieldInputStream.wrap(stream), handler, EMPTY_CONTEXT);
    } catch (SecurityException e) {
        throw e;
    } catch (Exception e) {
        if (throwMalformed && ((e instanceof CharConversionException) || (e.getCause() instanceof CharConversionException))) {
            throw new MalformedCharException(e);
        }
    }
    return handler.rootElement;
}
```
constructors:
```java
XmlRootExtractor() {
}

ExtractorHandler() {
}

public MalformedCharException(Exception e) {
    super(e);
}
```
fieldDeclarations:
```java
private static final ParseContext EMPTY_CONTEXT = new ParseContext();
```
setters:

imports: javax.xml.namespace.QName, org.apache.commons.io.input.CloseShieldInputStream, org.apache.commons.io.input.UnsynchronizedByteArrayInputStream, org.apache.tika.detect.XmlRootExtractor.ExtractorHandler, org.apache.tika.detect.XmlRootExtractor.MalformedCharException, org.apache.tika.parser.ParseContext, org.apache.tika.utils.XMLReaderUtils, org.xml.sax.ContentHandler, org.xml.sax.helpers.DefaultHandler

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.detect
- class name MUST be: XmlRootExtractorextractRootElement_CloseShieldInputStreamwrapFikaTest2
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COVERAGE CHECK FAILED - Test passed but target method NOT covered
================================================================================

Covered methods (1):
  ✓ org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream, boolean)

NOT covered methods (1):
  ✗ org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)

The call chain breaks between:
  'org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream, boolean)' → 'org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)'

Ensure 'org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream, boolean)' properly calls 'org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)'.
================================================================================



====================================================================================================
TEST CASE 21/24 — ITERATION 4
Entry Point: org.apache.tika.detect.XmlRootExtractor.extractRootElement(byte[])
Third Party Method: org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.detect.XmlRootExtractor.extractRootElement(byte[])
thirdPartyMethod: org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
path: org.apache.tika.detect.XmlRootExtractor.extractRootElement(byte[]) -> org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream, boolean) -> org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
methodSources:
```java
public QName extractRootElement(byte[] data) {
    // this loop should be very rare
    while (true) {
        try {
            // PATH: Test should invoke the next XmlRootExtractor.extractRootElement(...) [step in execution path]
            return extractRootElement(new UnsynchronizedByteArrayInputStream(data), true);
        } catch (MalformedCharException e) {
            // see TIKA-3596, try to handle truncated/bad encoded XML files
            int newLen = data.length / 2;
            if ((newLen % 2) == 1) {
                newLen--;
            }
            if (newLen > 0) {
                data = Arrays.copyOf(data, newLen);
            } else {
                break;
            }
        }
    } 
    return null;
}

private QName extractRootElement(InputStream stream, boolean throwMalformed) {
    ExtractorHandler handler = new ExtractorHandler();
    try {
        // PATH: Test should invoke the next CloseShieldInputStream.wrap(...) [step in execution path]
        XMLReaderUtils.parseSAX(CloseShieldInputStream.wrap(stream), handler, EMPTY_CONTEXT);
    } catch (SecurityException e) {
        throw e;
    } catch (Exception e) {
        if (throwMalformed && ((e instanceof CharConversionException) || (e.getCause() instanceof CharConversionException))) {
            throw new MalformedCharException(e);
        }
    }
    return handler.rootElement;
}
```
constructors:
```java
XmlRootExtractor() {
}

ExtractorHandler() {
}

public MalformedCharException(Exception e) {
    super(e);
}
```
fieldDeclarations:
```java
private static final ParseContext EMPTY_CONTEXT = new ParseContext();
```
setters:

imports: javax.xml.namespace.QName, org.apache.commons.io.input.CloseShieldInputStream, org.apache.commons.io.input.UnsynchronizedByteArrayInputStream, org.apache.tika.detect.XmlRootExtractor.ExtractorHandler, org.apache.tika.detect.XmlRootExtractor.MalformedCharException, org.apache.tika.parser.ParseContext, org.apache.tika.utils.XMLReaderUtils, org.xml.sax.ContentHandler, org.xml.sax.helpers.DefaultHandler

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.detect
- class name MUST be: XmlRootExtractorextractRootElement_CloseShieldInputStreamwrapFikaTest2
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COVERAGE CHECK FAILED - Test passed but target method NOT covered
================================================================================

Covered methods (1):
  ✓ org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream, boolean)

NOT covered methods (1):
  ✗ org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)

The call chain breaks between:
  'org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream, boolean)' → 'org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)'

Ensure 'org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream, boolean)' properly calls 'org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)'.
================================================================================



====================================================================================================
TEST CASE 21/24 — ITERATION 5
Entry Point: org.apache.tika.detect.XmlRootExtractor.extractRootElement(byte[])
Third Party Method: org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.detect.XmlRootExtractor.extractRootElement(byte[])
thirdPartyMethod: org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
path: org.apache.tika.detect.XmlRootExtractor.extractRootElement(byte[]) -> org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream, boolean) -> org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)
methodSources:
```java
public QName extractRootElement(byte[] data) {
    // this loop should be very rare
    while (true) {
        try {
            // PATH: Test should invoke the next XmlRootExtractor.extractRootElement(...) [step in execution path]
            return extractRootElement(new UnsynchronizedByteArrayInputStream(data), true);
        } catch (MalformedCharException e) {
            // see TIKA-3596, try to handle truncated/bad encoded XML files
            int newLen = data.length / 2;
            if ((newLen % 2) == 1) {
                newLen--;
            }
            if (newLen > 0) {
                data = Arrays.copyOf(data, newLen);
            } else {
                break;
            }
        }
    } 
    return null;
}

private QName extractRootElement(InputStream stream, boolean throwMalformed) {
    ExtractorHandler handler = new ExtractorHandler();
    try {
        // PATH: Test should invoke the next CloseShieldInputStream.wrap(...) [step in execution path]
        XMLReaderUtils.parseSAX(CloseShieldInputStream.wrap(stream), handler, EMPTY_CONTEXT);
    } catch (SecurityException e) {
        throw e;
    } catch (Exception e) {
        if (throwMalformed && ((e instanceof CharConversionException) || (e.getCause() instanceof CharConversionException))) {
            throw new MalformedCharException(e);
        }
    }
    return handler.rootElement;
}
```
constructors:
```java
XmlRootExtractor() {
}

ExtractorHandler() {
}

public MalformedCharException(Exception e) {
    super(e);
}
```
fieldDeclarations:
```java
private static final ParseContext EMPTY_CONTEXT = new ParseContext();
```
setters:

imports: javax.xml.namespace.QName, org.apache.commons.io.input.CloseShieldInputStream, org.apache.commons.io.input.UnsynchronizedByteArrayInputStream, org.apache.tika.detect.XmlRootExtractor.ExtractorHandler, org.apache.tika.detect.XmlRootExtractor.MalformedCharException, org.apache.tika.parser.ParseContext, org.apache.tika.utils.XMLReaderUtils, org.xml.sax.ContentHandler, org.xml.sax.helpers.DefaultHandler

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.detect
- class name MUST be: XmlRootExtractorextractRootElement_CloseShieldInputStreamwrapFikaTest2
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COVERAGE CHECK FAILED - Test passed but target method NOT covered
================================================================================

Covered methods (1):
  ✓ org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream, boolean)

NOT covered methods (1):
  ✗ org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)

The call chain breaks between:
  'org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream, boolean)' → 'org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)'

Ensure 'org.apache.tika.detect.XmlRootExtractor.extractRootElement(java.io.InputStream, boolean)' properly calls 'org.apache.commons.io.input.CloseShieldInputStream.wrap(java.io.InputStream)'.
================================================================================



====================================================================================================
TEST CASE 22/24 — ITERATION 1
Entry Point: org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFileName(org.apache.tika.metadata.Metadata, java.lang.String, int)
Third Party Method: org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFileName(org.apache.tika.metadata.Metadata, java.lang.String, int)
thirdPartyMethod: org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)
path: org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFileName(org.apache.tika.metadata.Metadata, java.lang.String, int) -> org.apache.tika.io.FilenameUtils.getPrefixLength(java.lang.String) -> org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)
methodSources:
```java
public static String getSanitizedEmbeddedFileName(Metadata metadata, String defaultExtension, int maxLength) {
    String path = getEmbeddedName(metadata);
    // fName could be a full path or null
    if (StringUtils.isBlank(path)) {
        return null;
    }
    path = path.replaceAll("\u0000", " ");
    if (path.startsWith("\"") && path.endsWith("\"")) {
        path = path.substring(1, path.length() - 1);
    }
    // PATH: Test should invoke the next FilenameUtils.getPrefixLength(...) [step in execution path]
    int prefixLength = getPrefixLength(path);
    if (prefixLength > 0) {
        path = path.substring(prefixLength);
    }
    path = path.replaceAll("[:\\\\]+", "/");
    String fName = getName(path);
    fName = normalize(fName);
    String extension = FilenameUtils.getSuffixFromPath(fName);
    if (extension.equals(fName)) {
        return null;
    }
    String namePart = null;
    if (StringUtils.isBlank(extension)) {
        namePart = fName;
        extension = calculateExtension(metadata, defaultExtension);
    } else {
        namePart = fName.substring(0, fName.length() - extension.length());
    }
    if (StringUtils.isBlank(namePart)) {
        return null;
    }
    // remove all initial .
    namePart = namePart.replaceAll("\\A\\.+", "_");
    // defense in depth. We shouldn't need this
    namePart = namePart.replaceAll("(\\.\\.)+", "_");
    namePart = namePart.replaceAll("[/\\\\]+", "_");
    namePart = namePart.replaceAll(":+", "_");
    namePart = namePart.trim();
    if (StringUtils.isBlank(namePart)) {
        return null;
    }
    // if path is > max length, return only the name part
    if (namePart.length() > maxLength) {
        return (namePart.substring(0, (maxLength - extension.length()) - 3) + "...") + extension;
    }
    return namePart + extension;
}

private static int getPrefixLength(String path) {
    // PATH: Test should invoke the next FilenameUtils.getPrefixLength(...) [step in execution path]
    int prefixLength = FilenameUtils.getPrefixLength(path);
    if (prefixLength > 0) {
        return prefixLength;
    }
    if ((((path.length() == 2) && (path.charAt(0) >= 'A')) && (path.charAt(0) <= 'Z')) && (path.charAt(1) == ':')) {
        return 2;
    }
    return 0;
}
```
constructors:
```java
FilenameUtils() {
}
```
fieldDeclarations:
```java
private static final MimeTypes MIME_TYPES = MimeTypes.getDefaultMimeTypes();
private static final Pattern PROTOCOL_PATTERN = Pattern.compile("[A-Za-z0-9]{1,10}://+");
/**
 * Reserved characters
 */
public static final char[] RESERVED_FILENAME_CHARACTERS = new char[]{ 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, '?', ':', '*', '<', '>', '|', '"', '\'' };
private static final HashSet<Character> RESERVED = new HashSet<>(38);
private static final Pattern ASCII_NUMERIC = Pattern.compile("\\A\\.(?i)[a-z0-9]{1,5}\\Z");
```
setters:

imports: org.apache.commons.io.FilenameUtils, org.apache.tika.metadata.Metadata, org.apache.tika.mime.MimeType, org.apache.tika.mime.MimeTypeException, org.apache.tika.mime.MimeTypes, org.apache.tika.utils.StringUtils

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.io
- class name MUST be: FilenameUtilsgetPrefixLength_FilenameUtilsgetPrefixLengthFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):



====================================================================================================
TEST CASE 22/24 — ITERATION 2
Entry Point: org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFileName(org.apache.tika.metadata.Metadata, java.lang.String, int)
Third Party Method: org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFileName(org.apache.tika.metadata.Metadata, java.lang.String, int)
thirdPartyMethod: org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)
path: org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFileName(org.apache.tika.metadata.Metadata, java.lang.String, int) -> org.apache.tika.io.FilenameUtils.getPrefixLength(java.lang.String) -> org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)
methodSources:
```java
public static String getSanitizedEmbeddedFileName(Metadata metadata, String defaultExtension, int maxLength) {
    String path = getEmbeddedName(metadata);
    // fName could be a full path or null
    if (StringUtils.isBlank(path)) {
        return null;
    }
    path = path.replaceAll("\u0000", " ");
    if (path.startsWith("\"") && path.endsWith("\"")) {
        path = path.substring(1, path.length() - 1);
    }
    // PATH: Test should invoke the next FilenameUtils.getPrefixLength(...) [step in execution path]
    int prefixLength = getPrefixLength(path);
    if (prefixLength > 0) {
        path = path.substring(prefixLength);
    }
    path = path.replaceAll("[:\\\\]+", "/");
    String fName = getName(path);
    fName = normalize(fName);
    String extension = FilenameUtils.getSuffixFromPath(fName);
    if (extension.equals(fName)) {
        return null;
    }
    String namePart = null;
    if (StringUtils.isBlank(extension)) {
        namePart = fName;
        extension = calculateExtension(metadata, defaultExtension);
    } else {
        namePart = fName.substring(0, fName.length() - extension.length());
    }
    if (StringUtils.isBlank(namePart)) {
        return null;
    }
    // remove all initial .
    namePart = namePart.replaceAll("\\A\\.+", "_");
    // defense in depth. We shouldn't need this
    namePart = namePart.replaceAll("(\\.\\.)+", "_");
    namePart = namePart.replaceAll("[/\\\\]+", "_");
    namePart = namePart.replaceAll(":+", "_");
    namePart = namePart.trim();
    if (StringUtils.isBlank(namePart)) {
        return null;
    }
    // if path is > max length, return only the name part
    if (namePart.length() > maxLength) {
        return (namePart.substring(0, (maxLength - extension.length()) - 3) + "...") + extension;
    }
    return namePart + extension;
}

private static int getPrefixLength(String path) {
    // PATH: Test should invoke the next FilenameUtils.getPrefixLength(...) [step in execution path]
    int prefixLength = FilenameUtils.getPrefixLength(path);
    if (prefixLength > 0) {
        return prefixLength;
    }
    if ((((path.length() == 2) && (path.charAt(0) >= 'A')) && (path.charAt(0) <= 'Z')) && (path.charAt(1) == ':')) {
        return 2;
    }
    return 0;
}
```
constructors:
```java
FilenameUtils() {
}
```
fieldDeclarations:
```java
private static final MimeTypes MIME_TYPES = MimeTypes.getDefaultMimeTypes();
private static final Pattern PROTOCOL_PATTERN = Pattern.compile("[A-Za-z0-9]{1,10}://+");
/**
 * Reserved characters
 */
public static final char[] RESERVED_FILENAME_CHARACTERS = new char[]{ 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, '?', ':', '*', '<', '>', '|', '"', '\'' };
private static final HashSet<Character> RESERVED = new HashSet<>(38);
private static final Pattern ASCII_NUMERIC = Pattern.compile("\\A\\.(?i)[a-z0-9]{1,5}\\Z");
```
setters:

imports: org.apache.commons.io.FilenameUtils, org.apache.tika.metadata.Metadata, org.apache.tika.mime.MimeType, org.apache.tika.mime.MimeTypeException, org.apache.tika.mime.MimeTypes, org.apache.tika.utils.StringUtils

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.io
- class name MUST be: FilenameUtilsgetPrefixLength_FilenameUtilsgetPrefixLengthFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COVERAGE CHECK FAILED - Test passed but target method NOT covered
================================================================================

NOT covered methods (2):
  ✗ org.apache.tika.io.FilenameUtils.getPrefixLength(java.lang.String)
  ✗ org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)

No methods in the call chain were reached.
Ensure the test properly invokes the entry point 'org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFileName(org.apache.tika.metadata.Metadata, java.lang.String, int)' to reach 'org.apache.tika.io.FilenameUtils.getPrefixLength(java.lang.String)'.
================================================================================



====================================================================================================
TEST CASE 22/24 — ITERATION 3
Entry Point: org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFileName(org.apache.tika.metadata.Metadata, java.lang.String, int)
Third Party Method: org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFileName(org.apache.tika.metadata.Metadata, java.lang.String, int)
thirdPartyMethod: org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)
path: org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFileName(org.apache.tika.metadata.Metadata, java.lang.String, int) -> org.apache.tika.io.FilenameUtils.getPrefixLength(java.lang.String) -> org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)
methodSources:
```java
public static String getSanitizedEmbeddedFileName(Metadata metadata, String defaultExtension, int maxLength) {
    String path = getEmbeddedName(metadata);
    // fName could be a full path or null
    if (StringUtils.isBlank(path)) {
        return null;
    }
    path = path.replaceAll("\u0000", " ");
    if (path.startsWith("\"") && path.endsWith("\"")) {
        path = path.substring(1, path.length() - 1);
    }
    // PATH: Test should invoke the next FilenameUtils.getPrefixLength(...) [step in execution path]
    int prefixLength = getPrefixLength(path);
    if (prefixLength > 0) {
        path = path.substring(prefixLength);
    }
    path = path.replaceAll("[:\\\\]+", "/");
    String fName = getName(path);
    fName = normalize(fName);
    String extension = FilenameUtils.getSuffixFromPath(fName);
    if (extension.equals(fName)) {
        return null;
    }
    String namePart = null;
    if (StringUtils.isBlank(extension)) {
        namePart = fName;
        extension = calculateExtension(metadata, defaultExtension);
    } else {
        namePart = fName.substring(0, fName.length() - extension.length());
    }
    if (StringUtils.isBlank(namePart)) {
        return null;
    }
    // remove all initial .
    namePart = namePart.replaceAll("\\A\\.+", "_");
    // defense in depth. We shouldn't need this
    namePart = namePart.replaceAll("(\\.\\.)+", "_");
    namePart = namePart.replaceAll("[/\\\\]+", "_");
    namePart = namePart.replaceAll(":+", "_");
    namePart = namePart.trim();
    if (StringUtils.isBlank(namePart)) {
        return null;
    }
    // if path is > max length, return only the name part
    if (namePart.length() > maxLength) {
        return (namePart.substring(0, (maxLength - extension.length()) - 3) + "...") + extension;
    }
    return namePart + extension;
}

private static int getPrefixLength(String path) {
    // PATH: Test should invoke the next FilenameUtils.getPrefixLength(...) [step in execution path]
    int prefixLength = FilenameUtils.getPrefixLength(path);
    if (prefixLength > 0) {
        return prefixLength;
    }
    if ((((path.length() == 2) && (path.charAt(0) >= 'A')) && (path.charAt(0) <= 'Z')) && (path.charAt(1) == ':')) {
        return 2;
    }
    return 0;
}
```
constructors:
```java
FilenameUtils() {
}
```
fieldDeclarations:
```java
private static final MimeTypes MIME_TYPES = MimeTypes.getDefaultMimeTypes();
private static final Pattern PROTOCOL_PATTERN = Pattern.compile("[A-Za-z0-9]{1,10}://+");
/**
 * Reserved characters
 */
public static final char[] RESERVED_FILENAME_CHARACTERS = new char[]{ 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, '?', ':', '*', '<', '>', '|', '"', '\'' };
private static final HashSet<Character> RESERVED = new HashSet<>(38);
private static final Pattern ASCII_NUMERIC = Pattern.compile("\\A\\.(?i)[a-z0-9]{1,5}\\Z");
```
setters:

imports: org.apache.commons.io.FilenameUtils, org.apache.tika.metadata.Metadata, org.apache.tika.mime.MimeType, org.apache.tika.mime.MimeTypeException, org.apache.tika.mime.MimeTypes, org.apache.tika.utils.StringUtils

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.io
- class name MUST be: FilenameUtilsgetPrefixLength_FilenameUtilsgetPrefixLengthFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/io/FilenameUtilsgetPrefixLength_FilenameUtilsgetPrefixLengthFikaTest.java:[6,26] package org.mockito does not exist
[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/io/FilenameUtilsgetPrefixLength_FilenameUtilsgetPrefixLengthFikaTest.java:[6,1] static import only from classes and interfaces

================================================================================



====================================================================================================
TEST CASE 22/24 — ITERATION 4
Entry Point: org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFileName(org.apache.tika.metadata.Metadata, java.lang.String, int)
Third Party Method: org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFileName(org.apache.tika.metadata.Metadata, java.lang.String, int)
thirdPartyMethod: org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)
path: org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFileName(org.apache.tika.metadata.Metadata, java.lang.String, int) -> org.apache.tika.io.FilenameUtils.getPrefixLength(java.lang.String) -> org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)
methodSources:
```java
public static String getSanitizedEmbeddedFileName(Metadata metadata, String defaultExtension, int maxLength) {
    String path = getEmbeddedName(metadata);
    // fName could be a full path or null
    if (StringUtils.isBlank(path)) {
        return null;
    }
    path = path.replaceAll("\u0000", " ");
    if (path.startsWith("\"") && path.endsWith("\"")) {
        path = path.substring(1, path.length() - 1);
    }
    // PATH: Test should invoke the next FilenameUtils.getPrefixLength(...) [step in execution path]
    int prefixLength = getPrefixLength(path);
    if (prefixLength > 0) {
        path = path.substring(prefixLength);
    }
    path = path.replaceAll("[:\\\\]+", "/");
    String fName = getName(path);
    fName = normalize(fName);
    String extension = FilenameUtils.getSuffixFromPath(fName);
    if (extension.equals(fName)) {
        return null;
    }
    String namePart = null;
    if (StringUtils.isBlank(extension)) {
        namePart = fName;
        extension = calculateExtension(metadata, defaultExtension);
    } else {
        namePart = fName.substring(0, fName.length() - extension.length());
    }
    if (StringUtils.isBlank(namePart)) {
        return null;
    }
    // remove all initial .
    namePart = namePart.replaceAll("\\A\\.+", "_");
    // defense in depth. We shouldn't need this
    namePart = namePart.replaceAll("(\\.\\.)+", "_");
    namePart = namePart.replaceAll("[/\\\\]+", "_");
    namePart = namePart.replaceAll(":+", "_");
    namePart = namePart.trim();
    if (StringUtils.isBlank(namePart)) {
        return null;
    }
    // if path is > max length, return only the name part
    if (namePart.length() > maxLength) {
        return (namePart.substring(0, (maxLength - extension.length()) - 3) + "...") + extension;
    }
    return namePart + extension;
}

private static int getPrefixLength(String path) {
    // PATH: Test should invoke the next FilenameUtils.getPrefixLength(...) [step in execution path]
    int prefixLength = FilenameUtils.getPrefixLength(path);
    if (prefixLength > 0) {
        return prefixLength;
    }
    if ((((path.length() == 2) && (path.charAt(0) >= 'A')) && (path.charAt(0) <= 'Z')) && (path.charAt(1) == ':')) {
        return 2;
    }
    return 0;
}
```
constructors:
```java
FilenameUtils() {
}
```
fieldDeclarations:
```java
private static final MimeTypes MIME_TYPES = MimeTypes.getDefaultMimeTypes();
private static final Pattern PROTOCOL_PATTERN = Pattern.compile("[A-Za-z0-9]{1,10}://+");
/**
 * Reserved characters
 */
public static final char[] RESERVED_FILENAME_CHARACTERS = new char[]{ 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, '?', ':', '*', '<', '>', '|', '"', '\'' };
private static final HashSet<Character> RESERVED = new HashSet<>(38);
private static final Pattern ASCII_NUMERIC = Pattern.compile("\\A\\.(?i)[a-z0-9]{1,5}\\Z");
```
setters:

imports: org.apache.commons.io.FilenameUtils, org.apache.tika.metadata.Metadata, org.apache.tika.mime.MimeType, org.apache.tika.mime.MimeTypeException, org.apache.tika.mime.MimeTypes, org.apache.tika.utils.StringUtils

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.io
- class name MUST be: FilenameUtilsgetPrefixLength_FilenameUtilsgetPrefixLengthFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COVERAGE CHECK FAILED - Test passed but target method NOT covered
================================================================================

NOT covered methods (2):
  ✗ org.apache.tika.io.FilenameUtils.getPrefixLength(java.lang.String)
  ✗ org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)

No methods in the call chain were reached.
Ensure the test properly invokes the entry point 'org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFileName(org.apache.tika.metadata.Metadata, java.lang.String, int)' to reach 'org.apache.tika.io.FilenameUtils.getPrefixLength(java.lang.String)'.
================================================================================



====================================================================================================
TEST CASE 22/24 — ITERATION 5
Entry Point: org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFileName(org.apache.tika.metadata.Metadata, java.lang.String, int)
Third Party Method: org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFileName(org.apache.tika.metadata.Metadata, java.lang.String, int)
thirdPartyMethod: org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)
path: org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFileName(org.apache.tika.metadata.Metadata, java.lang.String, int) -> org.apache.tika.io.FilenameUtils.getPrefixLength(java.lang.String) -> org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)
methodSources:
```java
public static String getSanitizedEmbeddedFileName(Metadata metadata, String defaultExtension, int maxLength) {
    String path = getEmbeddedName(metadata);
    // fName could be a full path or null
    if (StringUtils.isBlank(path)) {
        return null;
    }
    path = path.replaceAll("\u0000", " ");
    if (path.startsWith("\"") && path.endsWith("\"")) {
        path = path.substring(1, path.length() - 1);
    }
    // PATH: Test should invoke the next FilenameUtils.getPrefixLength(...) [step in execution path]
    int prefixLength = getPrefixLength(path);
    if (prefixLength > 0) {
        path = path.substring(prefixLength);
    }
    path = path.replaceAll("[:\\\\]+", "/");
    String fName = getName(path);
    fName = normalize(fName);
    String extension = FilenameUtils.getSuffixFromPath(fName);
    if (extension.equals(fName)) {
        return null;
    }
    String namePart = null;
    if (StringUtils.isBlank(extension)) {
        namePart = fName;
        extension = calculateExtension(metadata, defaultExtension);
    } else {
        namePart = fName.substring(0, fName.length() - extension.length());
    }
    if (StringUtils.isBlank(namePart)) {
        return null;
    }
    // remove all initial .
    namePart = namePart.replaceAll("\\A\\.+", "_");
    // defense in depth. We shouldn't need this
    namePart = namePart.replaceAll("(\\.\\.)+", "_");
    namePart = namePart.replaceAll("[/\\\\]+", "_");
    namePart = namePart.replaceAll(":+", "_");
    namePart = namePart.trim();
    if (StringUtils.isBlank(namePart)) {
        return null;
    }
    // if path is > max length, return only the name part
    if (namePart.length() > maxLength) {
        return (namePart.substring(0, (maxLength - extension.length()) - 3) + "...") + extension;
    }
    return namePart + extension;
}

private static int getPrefixLength(String path) {
    // PATH: Test should invoke the next FilenameUtils.getPrefixLength(...) [step in execution path]
    int prefixLength = FilenameUtils.getPrefixLength(path);
    if (prefixLength > 0) {
        return prefixLength;
    }
    if ((((path.length() == 2) && (path.charAt(0) >= 'A')) && (path.charAt(0) <= 'Z')) && (path.charAt(1) == ':')) {
        return 2;
    }
    return 0;
}
```
constructors:
```java
FilenameUtils() {
}
```
fieldDeclarations:
```java
private static final MimeTypes MIME_TYPES = MimeTypes.getDefaultMimeTypes();
private static final Pattern PROTOCOL_PATTERN = Pattern.compile("[A-Za-z0-9]{1,10}://+");
/**
 * Reserved characters
 */
public static final char[] RESERVED_FILENAME_CHARACTERS = new char[]{ 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, '?', ':', '*', '<', '>', '|', '"', '\'' };
private static final HashSet<Character> RESERVED = new HashSet<>(38);
private static final Pattern ASCII_NUMERIC = Pattern.compile("\\A\\.(?i)[a-z0-9]{1,5}\\Z");
```
setters:

imports: org.apache.commons.io.FilenameUtils, org.apache.tika.metadata.Metadata, org.apache.tika.mime.MimeType, org.apache.tika.mime.MimeTypeException, org.apache.tika.mime.MimeTypes, org.apache.tika.utils.StringUtils

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.io
- class name MUST be: FilenameUtilsgetPrefixLength_FilenameUtilsgetPrefixLengthFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/io/FilenameUtilsgetPrefixLength_FilenameUtilsgetPrefixLengthFikaTest.java:[6,26] package org.mockito does not exist
[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/io/FilenameUtilsgetPrefixLength_FilenameUtilsgetPrefixLengthFikaTest.java:[6,1] static import only from classes and interfaces

================================================================================



====================================================================================================
TEST CASE 23/24 — ITERATION 1
Entry Point: org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFilePath(org.apache.tika.metadata.Metadata, java.lang.String, int)
Third Party Method: org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFilePath(org.apache.tika.metadata.Metadata, java.lang.String, int)
thirdPartyMethod: org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)
path: org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFilePath(org.apache.tika.metadata.Metadata, java.lang.String, int) -> org.apache.tika.io.FilenameUtils.getPrefixLength(java.lang.String) -> org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)
methodSources:
```java
/**
 * This tries to sanitize dangerous user generated embedded file paths.
 * If trusting these paths for writing files, users should run checks to make
 * sure that the generated file path does not zipslip out of the target directory.
 *
 * @param metadata
 * @param defaultExtension
 * @param maxLength
 * @return  */
public static String getSanitizedEmbeddedFilePath(Metadata metadata, String defaultExtension, int maxLength) {
    String path = getEmbeddedPath(metadata);
    // fName could be a full path or null
    if (StringUtils.isBlank(path)) {
        return null;
    }
    path = path.replaceAll("\u0000", " ");
    // PATH: Test should invoke the next FilenameUtils.getPrefixLength(...) [step in execution path]
    int prefixLength = getPrefixLength(path);
    if (prefixLength > 0) {
        path = path.substring(prefixLength);
    }
    path = path.replaceAll("\\\\", "/");
    path = removeProtocol(path);
    path = path.replaceAll(":+", "/");
    path = path.replaceAll("/+", "/");
    path = normalize(path);
    path = path.replaceAll("\\.{2,}", ".");
    path = path.replaceAll("\\./", "/");
    if (path.isBlank()) {
        return null;
    }
    path = path.replaceAll("\\A/+", "");
    path = path.replaceAll("/+\\Z", "");
    String fName = getName(path);
    if (StringUtils.isBlank(fName)) {
        return null;
    }
    String relPath = "";
    if (path.length() > fName.length()) {
        relPath = path.substring(0, (path.length() - fName.length()) - 1);
    }
    String extension = FilenameUtils.getSuffixFromPath(fName);
    if (extension.equals(path)) {
        return extension;
    }
    String namePart = null;
    if (StringUtils.isBlank(extension)) {
        namePart = path;
        extension = calculateExtension(metadata, defaultExtension);
    } else {
        namePart = fName.substring(0, fName.length() - extension.length());
    }
    if (StringUtils.isBlank(namePart)) {
        return null;
    }
    // remove all initial .
    namePart = namePart.replaceAll("\\A\\.+", "_");
    // defense in depth. We shouldn't need this
    namePart = namePart.replaceAll("\\.{2,}", ".");
    namePart = namePart.replaceAll("[/\\\\]+", "_");
    if (StringUtils.isBlank(namePart)) {
        return null;
    }
    String retPath = (StringUtils.isBlank(relPath)) ? namePart + extension : ((relPath + "/") + namePart) + extension;
    // if path is > max length, return only the name part
    if (retPath.length() > maxLength) {
        if (namePart.length() > maxLength) {
            return (namePart.substring(0, (maxLength - extension.length()) - 3) + "...") + extension;
        }
        return namePart + extension;
    }
    return retPath;
}

private static int getPrefixLength(String path) {
    // PATH: Test should invoke the next FilenameUtils.getPrefixLength(...) [step in execution path]
    int prefixLength = FilenameUtils.getPrefixLength(path);
    if (prefixLength > 0) {
        return prefixLength;
    }
    if ((((path.length() == 2) && (path.charAt(0) >= 'A')) && (path.charAt(0) <= 'Z')) && (path.charAt(1) == ':')) {
        return 2;
    }
    return 0;
}
```
constructors:
```java
FilenameUtils() {
}
```
fieldDeclarations:
```java
private static final MimeTypes MIME_TYPES = MimeTypes.getDefaultMimeTypes();
private static final Pattern PROTOCOL_PATTERN = Pattern.compile("[A-Za-z0-9]{1,10}://+");
/**
 * Reserved characters
 */
public static final char[] RESERVED_FILENAME_CHARACTERS = new char[]{ 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, '?', ':', '*', '<', '>', '|', '"', '\'' };
private static final HashSet<Character> RESERVED = new HashSet<>(38);
private static final Pattern ASCII_NUMERIC = Pattern.compile("\\A\\.(?i)[a-z0-9]{1,5}\\Z");
```
setters:

imports: org.apache.commons.io.FilenameUtils, org.apache.tika.metadata.Metadata, org.apache.tika.mime.MimeType, org.apache.tika.mime.MimeTypeException, org.apache.tika.mime.MimeTypes, org.apache.tika.utils.StringUtils

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.io
- class name MUST be: FilenameUtilsgetPrefixLength_FilenameUtilsgetPrefixLengthFikaTest2
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):



====================================================================================================
TEST CASE 23/24 — ITERATION 2
Entry Point: org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFilePath(org.apache.tika.metadata.Metadata, java.lang.String, int)
Third Party Method: org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFilePath(org.apache.tika.metadata.Metadata, java.lang.String, int)
thirdPartyMethod: org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)
path: org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFilePath(org.apache.tika.metadata.Metadata, java.lang.String, int) -> org.apache.tika.io.FilenameUtils.getPrefixLength(java.lang.String) -> org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)
methodSources:
```java
/**
 * This tries to sanitize dangerous user generated embedded file paths.
 * If trusting these paths for writing files, users should run checks to make
 * sure that the generated file path does not zipslip out of the target directory.
 *
 * @param metadata
 * @param defaultExtension
 * @param maxLength
 * @return  */
public static String getSanitizedEmbeddedFilePath(Metadata metadata, String defaultExtension, int maxLength) {
    String path = getEmbeddedPath(metadata);
    // fName could be a full path or null
    if (StringUtils.isBlank(path)) {
        return null;
    }
    path = path.replaceAll("\u0000", " ");
    // PATH: Test should invoke the next FilenameUtils.getPrefixLength(...) [step in execution path]
    int prefixLength = getPrefixLength(path);
    if (prefixLength > 0) {
        path = path.substring(prefixLength);
    }
    path = path.replaceAll("\\\\", "/");
    path = removeProtocol(path);
    path = path.replaceAll(":+", "/");
    path = path.replaceAll("/+", "/");
    path = normalize(path);
    path = path.replaceAll("\\.{2,}", ".");
    path = path.replaceAll("\\./", "/");
    if (path.isBlank()) {
        return null;
    }
    path = path.replaceAll("\\A/+", "");
    path = path.replaceAll("/+\\Z", "");
    String fName = getName(path);
    if (StringUtils.isBlank(fName)) {
        return null;
    }
    String relPath = "";
    if (path.length() > fName.length()) {
        relPath = path.substring(0, (path.length() - fName.length()) - 1);
    }
    String extension = FilenameUtils.getSuffixFromPath(fName);
    if (extension.equals(path)) {
        return extension;
    }
    String namePart = null;
    if (StringUtils.isBlank(extension)) {
        namePart = path;
        extension = calculateExtension(metadata, defaultExtension);
    } else {
        namePart = fName.substring(0, fName.length() - extension.length());
    }
    if (StringUtils.isBlank(namePart)) {
        return null;
    }
    // remove all initial .
    namePart = namePart.replaceAll("\\A\\.+", "_");
    // defense in depth. We shouldn't need this
    namePart = namePart.replaceAll("\\.{2,}", ".");
    namePart = namePart.replaceAll("[/\\\\]+", "_");
    if (StringUtils.isBlank(namePart)) {
        return null;
    }
    String retPath = (StringUtils.isBlank(relPath)) ? namePart + extension : ((relPath + "/") + namePart) + extension;
    // if path is > max length, return only the name part
    if (retPath.length() > maxLength) {
        if (namePart.length() > maxLength) {
            return (namePart.substring(0, (maxLength - extension.length()) - 3) + "...") + extension;
        }
        return namePart + extension;
    }
    return retPath;
}

private static int getPrefixLength(String path) {
    // PATH: Test should invoke the next FilenameUtils.getPrefixLength(...) [step in execution path]
    int prefixLength = FilenameUtils.getPrefixLength(path);
    if (prefixLength > 0) {
        return prefixLength;
    }
    if ((((path.length() == 2) && (path.charAt(0) >= 'A')) && (path.charAt(0) <= 'Z')) && (path.charAt(1) == ':')) {
        return 2;
    }
    return 0;
}
```
constructors:
```java
FilenameUtils() {
}
```
fieldDeclarations:
```java
private static final MimeTypes MIME_TYPES = MimeTypes.getDefaultMimeTypes();
private static final Pattern PROTOCOL_PATTERN = Pattern.compile("[A-Za-z0-9]{1,10}://+");
/**
 * Reserved characters
 */
public static final char[] RESERVED_FILENAME_CHARACTERS = new char[]{ 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, '?', ':', '*', '<', '>', '|', '"', '\'' };
private static final HashSet<Character> RESERVED = new HashSet<>(38);
private static final Pattern ASCII_NUMERIC = Pattern.compile("\\A\\.(?i)[a-z0-9]{1,5}\\Z");
```
setters:

imports: org.apache.commons.io.FilenameUtils, org.apache.tika.metadata.Metadata, org.apache.tika.mime.MimeType, org.apache.tika.mime.MimeTypeException, org.apache.tika.mime.MimeTypes, org.apache.tika.utils.StringUtils

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.io
- class name MUST be: FilenameUtilsgetPrefixLength_FilenameUtilsgetPrefixLengthFikaTest2
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COMPILATION ERRORS DETECTED
================================================================================

[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/io/FilenameUtilsgetPrefixLength_FilenameUtilsgetPrefixLengthFikaTest2.java:[6,26] package org.mockito does not exist
[ERROR] /part/01/Tmp/gamageyo/fika/experiments/tika/tika-core/src/test/java/org/apache/tika/io/FilenameUtilsgetPrefixLength_FilenameUtilsgetPrefixLengthFikaTest2.java:[6,1] static import only from classes and interfaces

================================================================================



====================================================================================================
TEST CASE 23/24 — ITERATION 3
Entry Point: org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFilePath(org.apache.tika.metadata.Metadata, java.lang.String, int)
Third Party Method: org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFilePath(org.apache.tika.metadata.Metadata, java.lang.String, int)
thirdPartyMethod: org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)
path: org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFilePath(org.apache.tika.metadata.Metadata, java.lang.String, int) -> org.apache.tika.io.FilenameUtils.getPrefixLength(java.lang.String) -> org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)
methodSources:
```java
/**
 * This tries to sanitize dangerous user generated embedded file paths.
 * If trusting these paths for writing files, users should run checks to make
 * sure that the generated file path does not zipslip out of the target directory.
 *
 * @param metadata
 * @param defaultExtension
 * @param maxLength
 * @return  */
public static String getSanitizedEmbeddedFilePath(Metadata metadata, String defaultExtension, int maxLength) {
    String path = getEmbeddedPath(metadata);
    // fName could be a full path or null
    if (StringUtils.isBlank(path)) {
        return null;
    }
    path = path.replaceAll("\u0000", " ");
    // PATH: Test should invoke the next FilenameUtils.getPrefixLength(...) [step in execution path]
    int prefixLength = getPrefixLength(path);
    if (prefixLength > 0) {
        path = path.substring(prefixLength);
    }
    path = path.replaceAll("\\\\", "/");
    path = removeProtocol(path);
    path = path.replaceAll(":+", "/");
    path = path.replaceAll("/+", "/");
    path = normalize(path);
    path = path.replaceAll("\\.{2,}", ".");
    path = path.replaceAll("\\./", "/");
    if (path.isBlank()) {
        return null;
    }
    path = path.replaceAll("\\A/+", "");
    path = path.replaceAll("/+\\Z", "");
    String fName = getName(path);
    if (StringUtils.isBlank(fName)) {
        return null;
    }
    String relPath = "";
    if (path.length() > fName.length()) {
        relPath = path.substring(0, (path.length() - fName.length()) - 1);
    }
    String extension = FilenameUtils.getSuffixFromPath(fName);
    if (extension.equals(path)) {
        return extension;
    }
    String namePart = null;
    if (StringUtils.isBlank(extension)) {
        namePart = path;
        extension = calculateExtension(metadata, defaultExtension);
    } else {
        namePart = fName.substring(0, fName.length() - extension.length());
    }
    if (StringUtils.isBlank(namePart)) {
        return null;
    }
    // remove all initial .
    namePart = namePart.replaceAll("\\A\\.+", "_");
    // defense in depth. We shouldn't need this
    namePart = namePart.replaceAll("\\.{2,}", ".");
    namePart = namePart.replaceAll("[/\\\\]+", "_");
    if (StringUtils.isBlank(namePart)) {
        return null;
    }
    String retPath = (StringUtils.isBlank(relPath)) ? namePart + extension : ((relPath + "/") + namePart) + extension;
    // if path is > max length, return only the name part
    if (retPath.length() > maxLength) {
        if (namePart.length() > maxLength) {
            return (namePart.substring(0, (maxLength - extension.length()) - 3) + "...") + extension;
        }
        return namePart + extension;
    }
    return retPath;
}

private static int getPrefixLength(String path) {
    // PATH: Test should invoke the next FilenameUtils.getPrefixLength(...) [step in execution path]
    int prefixLength = FilenameUtils.getPrefixLength(path);
    if (prefixLength > 0) {
        return prefixLength;
    }
    if ((((path.length() == 2) && (path.charAt(0) >= 'A')) && (path.charAt(0) <= 'Z')) && (path.charAt(1) == ':')) {
        return 2;
    }
    return 0;
}
```
constructors:
```java
FilenameUtils() {
}
```
fieldDeclarations:
```java
private static final MimeTypes MIME_TYPES = MimeTypes.getDefaultMimeTypes();
private static final Pattern PROTOCOL_PATTERN = Pattern.compile("[A-Za-z0-9]{1,10}://+");
/**
 * Reserved characters
 */
public static final char[] RESERVED_FILENAME_CHARACTERS = new char[]{ 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, '?', ':', '*', '<', '>', '|', '"', '\'' };
private static final HashSet<Character> RESERVED = new HashSet<>(38);
private static final Pattern ASCII_NUMERIC = Pattern.compile("\\A\\.(?i)[a-z0-9]{1,5}\\Z");
```
setters:

imports: org.apache.commons.io.FilenameUtils, org.apache.tika.metadata.Metadata, org.apache.tika.mime.MimeType, org.apache.tika.mime.MimeTypeException, org.apache.tika.mime.MimeTypes, org.apache.tika.utils.StringUtils

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.io
- class name MUST be: FilenameUtilsgetPrefixLength_FilenameUtilsgetPrefixLengthFikaTest2
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COVERAGE CHECK FAILED - Test passed but target method NOT covered
================================================================================

NOT covered methods (2):
  ✗ org.apache.tika.io.FilenameUtils.getPrefixLength(java.lang.String)
  ✗ org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)

No methods in the call chain were reached.
Ensure the test properly invokes the entry point 'org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFilePath(org.apache.tika.metadata.Metadata, java.lang.String, int)' to reach 'org.apache.tika.io.FilenameUtils.getPrefixLength(java.lang.String)'.
================================================================================



====================================================================================================
TEST CASE 23/24 — ITERATION 4
Entry Point: org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFilePath(org.apache.tika.metadata.Metadata, java.lang.String, int)
Third Party Method: org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFilePath(org.apache.tika.metadata.Metadata, java.lang.String, int)
thirdPartyMethod: org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)
path: org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFilePath(org.apache.tika.metadata.Metadata, java.lang.String, int) -> org.apache.tika.io.FilenameUtils.getPrefixLength(java.lang.String) -> org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)
methodSources:
```java
/**
 * This tries to sanitize dangerous user generated embedded file paths.
 * If trusting these paths for writing files, users should run checks to make
 * sure that the generated file path does not zipslip out of the target directory.
 *
 * @param metadata
 * @param defaultExtension
 * @param maxLength
 * @return  */
public static String getSanitizedEmbeddedFilePath(Metadata metadata, String defaultExtension, int maxLength) {
    String path = getEmbeddedPath(metadata);
    // fName could be a full path or null
    if (StringUtils.isBlank(path)) {
        return null;
    }
    path = path.replaceAll("\u0000", " ");
    // PATH: Test should invoke the next FilenameUtils.getPrefixLength(...) [step in execution path]
    int prefixLength = getPrefixLength(path);
    if (prefixLength > 0) {
        path = path.substring(prefixLength);
    }
    path = path.replaceAll("\\\\", "/");
    path = removeProtocol(path);
    path = path.replaceAll(":+", "/");
    path = path.replaceAll("/+", "/");
    path = normalize(path);
    path = path.replaceAll("\\.{2,}", ".");
    path = path.replaceAll("\\./", "/");
    if (path.isBlank()) {
        return null;
    }
    path = path.replaceAll("\\A/+", "");
    path = path.replaceAll("/+\\Z", "");
    String fName = getName(path);
    if (StringUtils.isBlank(fName)) {
        return null;
    }
    String relPath = "";
    if (path.length() > fName.length()) {
        relPath = path.substring(0, (path.length() - fName.length()) - 1);
    }
    String extension = FilenameUtils.getSuffixFromPath(fName);
    if (extension.equals(path)) {
        return extension;
    }
    String namePart = null;
    if (StringUtils.isBlank(extension)) {
        namePart = path;
        extension = calculateExtension(metadata, defaultExtension);
    } else {
        namePart = fName.substring(0, fName.length() - extension.length());
    }
    if (StringUtils.isBlank(namePart)) {
        return null;
    }
    // remove all initial .
    namePart = namePart.replaceAll("\\A\\.+", "_");
    // defense in depth. We shouldn't need this
    namePart = namePart.replaceAll("\\.{2,}", ".");
    namePart = namePart.replaceAll("[/\\\\]+", "_");
    if (StringUtils.isBlank(namePart)) {
        return null;
    }
    String retPath = (StringUtils.isBlank(relPath)) ? namePart + extension : ((relPath + "/") + namePart) + extension;
    // if path is > max length, return only the name part
    if (retPath.length() > maxLength) {
        if (namePart.length() > maxLength) {
            return (namePart.substring(0, (maxLength - extension.length()) - 3) + "...") + extension;
        }
        return namePart + extension;
    }
    return retPath;
}

private static int getPrefixLength(String path) {
    // PATH: Test should invoke the next FilenameUtils.getPrefixLength(...) [step in execution path]
    int prefixLength = FilenameUtils.getPrefixLength(path);
    if (prefixLength > 0) {
        return prefixLength;
    }
    if ((((path.length() == 2) && (path.charAt(0) >= 'A')) && (path.charAt(0) <= 'Z')) && (path.charAt(1) == ':')) {
        return 2;
    }
    return 0;
}
```
constructors:
```java
FilenameUtils() {
}
```
fieldDeclarations:
```java
private static final MimeTypes MIME_TYPES = MimeTypes.getDefaultMimeTypes();
private static final Pattern PROTOCOL_PATTERN = Pattern.compile("[A-Za-z0-9]{1,10}://+");
/**
 * Reserved characters
 */
public static final char[] RESERVED_FILENAME_CHARACTERS = new char[]{ 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, '?', ':', '*', '<', '>', '|', '"', '\'' };
private static final HashSet<Character> RESERVED = new HashSet<>(38);
private static final Pattern ASCII_NUMERIC = Pattern.compile("\\A\\.(?i)[a-z0-9]{1,5}\\Z");
```
setters:

imports: org.apache.commons.io.FilenameUtils, org.apache.tika.metadata.Metadata, org.apache.tika.mime.MimeType, org.apache.tika.mime.MimeTypeException, org.apache.tika.mime.MimeTypes, org.apache.tika.utils.StringUtils

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.io
- class name MUST be: FilenameUtilsgetPrefixLength_FilenameUtilsgetPrefixLengthFikaTest2
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COVERAGE CHECK FAILED - Test passed but target method NOT covered
================================================================================

NOT covered methods (2):
  ✗ org.apache.tika.io.FilenameUtils.getPrefixLength(java.lang.String)
  ✗ org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)

No methods in the call chain were reached.
Ensure the test properly invokes the entry point 'org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFilePath(org.apache.tika.metadata.Metadata, java.lang.String, int)' to reach 'org.apache.tika.io.FilenameUtils.getPrefixLength(java.lang.String)'.
================================================================================



====================================================================================================
TEST CASE 23/24 — ITERATION 5
Entry Point: org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFilePath(org.apache.tika.metadata.Metadata, java.lang.String, int)
Third Party Method: org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFilePath(org.apache.tika.metadata.Metadata, java.lang.String, int)
thirdPartyMethod: org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)
path: org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFilePath(org.apache.tika.metadata.Metadata, java.lang.String, int) -> org.apache.tika.io.FilenameUtils.getPrefixLength(java.lang.String) -> org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)
methodSources:
```java
/**
 * This tries to sanitize dangerous user generated embedded file paths.
 * If trusting these paths for writing files, users should run checks to make
 * sure that the generated file path does not zipslip out of the target directory.
 *
 * @param metadata
 * @param defaultExtension
 * @param maxLength
 * @return  */
public static String getSanitizedEmbeddedFilePath(Metadata metadata, String defaultExtension, int maxLength) {
    String path = getEmbeddedPath(metadata);
    // fName could be a full path or null
    if (StringUtils.isBlank(path)) {
        return null;
    }
    path = path.replaceAll("\u0000", " ");
    // PATH: Test should invoke the next FilenameUtils.getPrefixLength(...) [step in execution path]
    int prefixLength = getPrefixLength(path);
    if (prefixLength > 0) {
        path = path.substring(prefixLength);
    }
    path = path.replaceAll("\\\\", "/");
    path = removeProtocol(path);
    path = path.replaceAll(":+", "/");
    path = path.replaceAll("/+", "/");
    path = normalize(path);
    path = path.replaceAll("\\.{2,}", ".");
    path = path.replaceAll("\\./", "/");
    if (path.isBlank()) {
        return null;
    }
    path = path.replaceAll("\\A/+", "");
    path = path.replaceAll("/+\\Z", "");
    String fName = getName(path);
    if (StringUtils.isBlank(fName)) {
        return null;
    }
    String relPath = "";
    if (path.length() > fName.length()) {
        relPath = path.substring(0, (path.length() - fName.length()) - 1);
    }
    String extension = FilenameUtils.getSuffixFromPath(fName);
    if (extension.equals(path)) {
        return extension;
    }
    String namePart = null;
    if (StringUtils.isBlank(extension)) {
        namePart = path;
        extension = calculateExtension(metadata, defaultExtension);
    } else {
        namePart = fName.substring(0, fName.length() - extension.length());
    }
    if (StringUtils.isBlank(namePart)) {
        return null;
    }
    // remove all initial .
    namePart = namePart.replaceAll("\\A\\.+", "_");
    // defense in depth. We shouldn't need this
    namePart = namePart.replaceAll("\\.{2,}", ".");
    namePart = namePart.replaceAll("[/\\\\]+", "_");
    if (StringUtils.isBlank(namePart)) {
        return null;
    }
    String retPath = (StringUtils.isBlank(relPath)) ? namePart + extension : ((relPath + "/") + namePart) + extension;
    // if path is > max length, return only the name part
    if (retPath.length() > maxLength) {
        if (namePart.length() > maxLength) {
            return (namePart.substring(0, (maxLength - extension.length()) - 3) + "...") + extension;
        }
        return namePart + extension;
    }
    return retPath;
}

private static int getPrefixLength(String path) {
    // PATH: Test should invoke the next FilenameUtils.getPrefixLength(...) [step in execution path]
    int prefixLength = FilenameUtils.getPrefixLength(path);
    if (prefixLength > 0) {
        return prefixLength;
    }
    if ((((path.length() == 2) && (path.charAt(0) >= 'A')) && (path.charAt(0) <= 'Z')) && (path.charAt(1) == ':')) {
        return 2;
    }
    return 0;
}
```
constructors:
```java
FilenameUtils() {
}
```
fieldDeclarations:
```java
private static final MimeTypes MIME_TYPES = MimeTypes.getDefaultMimeTypes();
private static final Pattern PROTOCOL_PATTERN = Pattern.compile("[A-Za-z0-9]{1,10}://+");
/**
 * Reserved characters
 */
public static final char[] RESERVED_FILENAME_CHARACTERS = new char[]{ 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, '?', ':', '*', '<', '>', '|', '"', '\'' };
private static final HashSet<Character> RESERVED = new HashSet<>(38);
private static final Pattern ASCII_NUMERIC = Pattern.compile("\\A\\.(?i)[a-z0-9]{1,5}\\Z");
```
setters:

imports: org.apache.commons.io.FilenameUtils, org.apache.tika.metadata.Metadata, org.apache.tika.mime.MimeType, org.apache.tika.mime.MimeTypeException, org.apache.tika.mime.MimeTypes, org.apache.tika.utils.StringUtils

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.io
- class name MUST be: FilenameUtilsgetPrefixLength_FilenameUtilsgetPrefixLengthFikaTest2
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):
================================================================================
COVERAGE CHECK FAILED - Test passed but target method NOT covered
================================================================================

NOT covered methods (2):
  ✗ org.apache.tika.io.FilenameUtils.getPrefixLength(java.lang.String)
  ✗ org.apache.commons.io.FilenameUtils.getPrefixLength(java.lang.String)

No methods in the call chain were reached.
Ensure the test properly invokes the entry point 'org.apache.tika.io.FilenameUtils.getSanitizedEmbeddedFilePath(org.apache.tika.metadata.Metadata, java.lang.String, int)' to reach 'org.apache.tika.io.FilenameUtils.getPrefixLength(java.lang.String)'.
================================================================================



====================================================================================================
TEST CASE 24/24 — ITERATION 1
Entry Point: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
Third Party Method: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
====================================================================================================
You are an expert Java developer who writes good unit tests in order to maximize code coverage. You are specialized in Maven and JUnit 5 testing framework.

Generate a JUnit 5 test that executes the full chain of method calls starting from the specified entry point method and reaching the specified third-party method. No assertions, inspections, or verifications are required. The test’s only goal is to try invoking the given third-party method during execution. 

You are provided with:
entryPoint: Fully qualified public method where execution must begin.
thirdPartyMethod: Fully qualified third-party method that must be invoked.
path: Ordered list of method calls that must be traversed during execution.
methodSources: Complete and exact source code for all methods in the call chain.
constructors: All constructors of the class containing the entryPoint. Use one of these constructors to instantiate the class in the test. Then use that instance to call the entryPoint method.
fieldDeclarations: Instance variables and class variables of the class containing the entryPoint. These are the fields that can be accessed or set when creating the test.
setters: All setters of the entryPoint class that can modify the declared fields.
imports: All non-core-java imports that may be required by the test.

entryPoint: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext)
thirdPartyMethod: org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
path: org.apache.tika.embedder.ExternalEmbedder.embed(org.apache.tika.metadata.Metadata, java.io.InputStream, java.io.OutputStream, org.apache.tika.parser.ParseContext) -> org.apache.tika.embedder.ExternalEmbedder.sendStdOutToOutputStream(java.lang.Process, java.io.OutputStream) -> org.apache.commons.io.IOUtils.copy(java.io.InputStream, java.io.OutputStream)
methodSources:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) // PATH: Test should invoke the next ExternalEmbedder.sendStdOutToOutputStream(...) [step in execution path]
        {
            sendStdOutToOutputStream(process, outputStream);
        } else {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}

/**
 * Sends the standard output of the given
 * process to the given output stream. Potential exceptions are
 * ignored.
 * <p>
 * Note that the given output stream is <em>not</em> closed by this method.
 *
 * @param process
 * 		the process
 * @param outputStream
 * 		the putput stream to send to standard input of the process
 */
private void sendStdOutToOutputStream(final Process process, final OutputStream outputStream) {
    try // PATH: Test should invoke the next IOUtils.copy(...) [step in execution path]
    {
        IOUtils.copy(process.getInputStream(), outputStream);
    } catch (IOException e) {
        System.out.println("ERROR: " + e.getMessage());
    }
}
```
constructors:
```java
ExternalEmbedder() {
}
```
fieldDeclarations:
```java
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_TOKEN = "${METADATA}";
/**
 * Token to be replaced with a String array of metadata assignment command
 * arguments
 */
public static final String METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN = "${METADATA_SERIALIZED}";
private static final long serialVersionUID = -2828829275642475697L;
private final TemporaryResources tmp = new TemporaryResources();
/**
 * Media types supported by the external program.
 */
private Set<MediaType> supportedEmbedTypes = Collections.emptySet();
/**
 * Mapping of Tika metadata to command line parameters.
 */
private Map<Property, String[]> metadataCommandArguments = null;
/**
 * The external command to invoke.
 *
 * @see Runtime#exec(String[])
 */
private String[] command = new String[]{ "sed", "-e", "$a\\
" + METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, ExternalParser.INPUT_FILE_TOKEN };
private String commandAssignmentOperator = "=";
private String commandAssignmentDelimeter = ", ";
private String commandAppendOperator = "=";
private boolean quoteAssignmentValues = false;
```
setters:
```java
/**
 * Executes the configured external command and passes the given document
 * stream as a simple XHTML document to the given SAX content handler.
 * Metadata is only extracted if {@link #setMetadataCommandArguments(Map)}
 * has been called to set arguments.
 */
@Override
public void embed(final Metadata metadata, final InputStream inputStream, final OutputStream outputStream, final ParseContext context) throws IOException, TikaException {
    boolean inputToStdIn = true;
    boolean outputFromStdOut = true;
    boolean hasMetadataCommandArguments = (metadataCommandArguments != null) && (!metadataCommandArguments.isEmpty());
    boolean serializeMetadataCommandArgumentsToken = false;
    boolean replacedMetadataCommandArgumentsToken = false;
    TikaInputStream tikaInputStream = TikaInputStream.get(inputStream);
    File tempOutputFile = null;
    List<String> commandMetadataSegments = null;
    if (hasMetadataCommandArguments) {
        commandMetadataSegments = getCommandMetadataSegments(metadata);
    }
    // Build our command
    String[] origCmd = command;
    List<String> cmd = new ArrayList<>();
    for (String commandSegment : origCmd) {
        if (commandSegment.contains(ExternalParser.INPUT_FILE_TOKEN)) {
            commandSegment = commandSegment.replace(ExternalParser.INPUT_FILE_TOKEN, tikaInputStream.getFile().toString());
            inputToStdIn = false;
        }
        if (commandSegment.contains(ExternalParser.OUTPUT_FILE_TOKEN)) {
            tempOutputFile = tmp.createTemporaryFile();
            commandSegment = commandSegment.replace(ExternalParser.OUTPUT_FILE_TOKEN, tempOutputFile.toString());
            outputFromStdOut = false;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
            serializeMetadataCommandArgumentsToken = true;
        }
        if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_TOKEN)) {
            if (hasMetadataCommandArguments) {
                cmd.addAll(commandMetadataSegments);
            }
            replacedMetadataCommandArgumentsToken = true;
        } else {
            cmd.add(commandSegment);
        }
    }
    if (hasMetadataCommandArguments) {
        if (serializeMetadataCommandArgumentsToken) {
            // Find all metadata tokens and replace with encapsulated metadata
            int i = 0;
            for (String commandSegment : cmd) {
                if (commandSegment.contains(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN)) {
                    commandSegment = commandSegment.replace(METADATA_COMMAND_ARGUMENTS_SERIALIZED_TOKEN, serializeMetadata(commandMetadataSegments));
                    cmd.set(i, commandSegment);
                }
                i++;
            }
        } else if ((!replacedMetadataCommandArgumentsToken) && (!serializeMetadataCommandArgumentsToken)) {
            // Tack metadata onto the end of the cmd as arguments
            cmd.addAll(commandMetadataSegments);
        }
    }
    // Execute
    Process process;
    if (cmd.toArray().length == 1) {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new)[0]);
    } else {
        process = Runtime.getRuntime().exec(cmd.toArray(String[]::new));
    }
    UnsynchronizedByteArrayOutputStream stdErrOutputStream = UnsynchronizedByteArrayOutputStream.builder().get();
    try {
        sendStdErrToOutputStream(process, stdErrOutputStream);
        if (inputToStdIn) {
            sendInputStreamToStdIn(inputStream, process);
        } else {
            // We're not writing to std in this case so close
            process.getOutputStream().close();
        }
        if (outputFromStdOut) {
            sendStdOutToOutputStream(process, outputStream);
        } else {
            tmp.dispose();
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
            // The command is finished, read the output file into the given output stream
            InputStream tempOutputFileInputStream = TikaInputStream.get(tempOutputFile.toPath());
            IOUtils.copy(tempOutputFileInputStream, outputStream);
        }
    } finally {
        if (outputFromStdOut) {
            try {
                process.waitFor();
            } catch (InterruptedException ignore) {
            }
        } else {
            try {
                // Clean up temp output files
                tempOutputFile.delete();
            } catch (Exception e) {
                // swallow
            }
        }
        if (!inputToStdIn) {
            // Close input file (and delete if created by up
            // TemporaryResources.createTemporaryFile)
            IOUtils.closeQuietly(tikaInputStream);
        }
        IOUtils.closeQuietly(outputStream);
        IOUtils.closeQuietly(stdErrOutputStream);
        if (process.exitValue() != 0) {
            throw new TikaException(((("There was an error executing the command line" + "
Executable Command:

") + cmd) + "
Executable Error:

") + stdErrOutputStream.toString(UTF_8.name()));
        }
    }
}

/**
 * Sets the command to be run. This can include either of
 * {@link ExternalParser#INPUT_FILE_TOKEN} or
 * {@link ExternalParser#OUTPUT_FILE_TOKEN} if the command
 * needs filenames.
 *
 * @see Runtime#exec(String[])
 */
public void setCommand(String... command) {
    this.command = command;
}

/**
 * Sets the operator to append rather than replace a value for the command
 * line tool, i.e. "+=".
 *
 * @param commandAppendOperator
 */
public void setCommandAppendOperator(String commandAppendOperator) {
    this.commandAppendOperator = commandAppendOperator;
}

/**
 * Sets the delimiter for multiple assignments for the command line tool,
 * i.e. ", ".
 *
 * @param commandAssignmentDelimeter
 */
public void setCommandAssignmentDelimeter(String commandAssignmentDelimeter) {
    this.commandAssignmentDelimeter = commandAssignmentDelimeter;
}

/**
 * Sets the assignment operator for the command line tool, i.e. "=".
 *
 * @param commandAssignmentOperator
 */
public void setCommandAssignmentOperator(String commandAssignmentOperator) {
    this.commandAssignmentOperator = commandAssignmentOperator;
}

/**
 * Sets the map of Metadata keys to command line parameters. Set this to
 * null to disable Metadata embedding.
 *
 * @param arguments
 */
public void setMetadataCommandArguments(Map<Property, String[]> arguments) {
    this.metadataCommandArguments = arguments;
}

/**
 * Sets whether or not to quote assignment values, i.e. tag='value'.
 *
 * @param quoteAssignmentValues
 */
public void setQuoteAssignmentValues(boolean quoteAssignmentValues) {
    this.quoteAssignmentValues = quoteAssignmentValues;
}

public void setSupportedEmbedTypes(Set<MediaType> supportedEmbedTypes) {
    this.supportedEmbedTypes = Collections.unmodifiableSet(new HashSet<>(supportedEmbedTypes));
}
```
imports: org.apache.commons.io.IOUtils, org.apache.commons.io.output.AbstractByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream, org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.Builder, org.apache.tika.exception.TikaException, org.apache.tika.io.TemporaryResources, org.apache.tika.io.TikaInputStream, org.apache.tika.metadata.Metadata, org.apache.tika.metadata.Property, org.apache.tika.mime.MediaType, org.apache.tika.parser.ParseContext, org.apache.tika.parser.external.ExternalParser

Hard constraints:
- The test class MUST NOT extend any other class (no 'extends' keyword).
- The test class MUST NOT override any methods (no @Override annotations).
- Do NOT create anonymous inner classes (e.g., new ClassName() { ... }).
- Use real objects whenever possible.
- Use mocks only when necessary, and ONLY for objects required as constructor parameters when instantiating the class that contains the entry-point method, provided those objects are not directly related to the target method call.
- Do NOT mock or spy on the class under test.
- Do NOT alter, stub, or control the behavior of ANY method in the call path.
- Use only the following test-related libraries: junit-jupiter, mockito-core, and mockito-junit-jupiter. Do not use any other testing or mocking libraries.
- Do NOT add any assertions, verifications, or inspections of state/logs/output.
- package declaration MUST be: org.apache.tika.embedder
- class name MUST be: ExternalEmbeddersendStdOutToOutputStream_IOUtilscopyFikaTest
- exactly ONE @Test method
- Return ONLY the complete Java source code.
- Do NOT include explanations, markdown, or extra text.


Previous Maven test output (if any; fix compilation/runtime issues while keeping ALL constraints):



